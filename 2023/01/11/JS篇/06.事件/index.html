<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>事件 | 欢迎来到我的小站</title><meta name="keywords" content="JS基础"><meta name="author" content="Liang Zui"><meta name="copyright" content="Liang Zui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="事件一、EventTarget 接口 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。 1、概述DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也">
<meta property="og:type" content="article">
<meta property="og:title" content="事件">
<meta property="og:url" content="http://example.com/2023/01/11/JS%E7%AF%87/06.%E4%BA%8B%E4%BB%B6/index.html">
<meta property="og:site_name" content="欢迎来到我的小站">
<meta property="og:description" content="事件一、EventTarget 接口 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。 1、概述DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images3.alphacoders.com/104/thumbbig-1043255.webp">
<meta property="article:published_time" content="2023-01-10T16:25:01.000Z">
<meta property="article:modified_time" content="2023-01-10T16:25:50.365Z">
<meta property="article:author" content="Liang Zui">
<meta property="article:tag" content="JS基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images3.alphacoders.com/104/thumbbig-1043255.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/11/JS%E7%AF%87/06.%E4%BA%8B%E4%BB%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '事件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-11 00:25:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.liangzui.top/img/icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">379</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-book"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images3.alphacoders.com/104/thumbbig-1043255.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">欢迎来到我的小站</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-book"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">事件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-10T16:25:01.000Z" title="发表于 2023-01-11 00:25:01">2023-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-10T16:25:50.365Z" title="更新于 2023-01-11 00:25:50">2023-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JS%E7%AF%87/">JS篇</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="事件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="一、EventTarget-接口"><a href="#一、EventTarget-接口" class="headerlink" title="一、EventTarget 接口"></a>一、EventTarget 接口</h2><p> 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 <strong>DOM 的事件编程</strong>。</p>
<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口</strong>。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h3 id="2、EventTarget-addEventListener"><a href="#2、EventTarget-addEventListener" class="headerlink" title="2、EventTarget.addEventListener()"></a>2、EventTarget.addEventListener()</h3><p><code>EventTarget.addEventListener()</code>用于<strong>在当前节点或对象上，定义一个特定事件的监听函数</strong>。<strong>一旦这个事件发生，就会执行监听函数</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line"><span class="comment">// 事件名称，监听函数 [，是否在捕获阶段触发]</span></span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<p>关于参数，有两个地方需要注意。</p>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">handleEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>addEventListener</code>方法的第二个参数，就是一个具有<code>handleEvent</code>方法的对象。</p>
<p>其次，<strong>第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象</strong>。该对象有以下属性。</p>
<blockquote>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
</blockquote>
<p>如果希望事件监听函数<strong>只执行一次</strong>，可以打开属性配置对象的<code>once</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只执行一次的代码</span></span><br><span class="line">&#125;, &#123;<span class="attr">once</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p>如果<strong>希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; print(<span class="string">&#x27;Hello&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数。</p>
<p>监听函数<strong>内部的<code>this</code>，指向当前事件所在的那个对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">para.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.nodeName); <span class="comment">// &quot;P&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h3 id="3、EventTarget-removeEventListener"><a href="#3、EventTarget-removeEventListener" class="headerlink" title="3、EventTarget.removeEventListener()"></a>3、EventTarget.removeEventListener()</h3><p><code>EventTarget.removeEventListener</code>方法<strong>用来移除<code>addEventListener</code>方法添加的事件监听函数</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);<span class="comment">// 移除无效，因为不是同一个监听函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, handleMouseDown, <span class="literal">true</span>);</span><br><span class="line">element.removeEventListener(<span class="string">&quot;mousedown&quot;</span>, handleMouseDown, <span class="literal">false</span>); <span class="comment">// 移除无效，第三个参数不一样</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h3 id="4、EventTarget-dispatchEvent"><a href="#4、EventTarget-dispatchEvent" class="headerlink" title="4、EventTarget.dispatchEvent()"></a>4、EventTarget.dispatchEvent()</h3><p><code>EventTarget.dispatchEvent</code>方法在当前节点上<strong>触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值</strong>，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>

<p><code>dispatchEvent</code>方法的<strong>参数是一个<code>Event</code>对象的实例</strong>（详见《Event 对象》章节）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，<strong>判断事件是否被取消</strong>了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canceled = !cb.dispatchEvent(event);</span><br><span class="line"><span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件取消&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件未取消&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、事件模型"><a href="#二、事件模型" class="headerlink" title="二、事件模型"></a>二、事件模型</h2><h3 id="1、监听函数"><a href="#1、监听函数" class="headerlink" title="1、监听函数"></a>1、监听函数</h3><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h4 id="1-2-HTML-的-on-属性"><a href="#1-2-HTML-的-on-属性" class="headerlink" title="1.2 HTML 的 on- 属性"></a>1.2 HTML 的 on- 属性</h4><p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span> <span class="comment">&lt;!-- 加圆括号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;触发事件&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦指定的事件发生，<code>on-</code>属性的值是原样传入 JavaScript 引擎执行。因此如果要执行函数，<strong>不要忘记加上一对圆括号</strong>。</p>
<p>使用这个方法指定的监听代码，只会在<strong>冒泡阶段触发</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&quot;console.log(2)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&quot;console.log(1)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;button&gt;</code>是<code> &lt;div&gt; </code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code> &lt;div&gt; </code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件<strong>从子元素开始冒泡到父元素。</strong></p>
<p>直接设置<code>on-</code>属性，与通过元素节点的<code>setAttribute</code>方法设置<code>on-</code>属性，效果是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(<span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;doSomething()&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// &lt;Element onclick=&quot;doSomething()&quot;&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-元素节点的事件属性-例：el-onclick"><a href="#1-2-元素节点的事件属性-例：el-onclick" class="headerlink" title="1.2 元素节点的事件属性 (例：el.onclick)"></a>1.2 元素节点的事件属性 (例：el.onclick)</h4><p>元素节点对象的<strong>事件属性</strong>，同样可以指定监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething; <span class="comment">// 注意这里是函数名，不加圆括号</span></span><br><span class="line"></span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">// onclick是元素的一个属性，它指向一个函数，在触发点击时执行此函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;触发事件&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这个方法指定的监听函数，也是只会在<strong>冒泡阶段触发</strong>。</p>
<p>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</p>
<h4 id="1-3-EventTarget-addEventListener"><a href="#1-3-EventTarget-addEventListener" class="headerlink" title="1.3 EventTarget.addEventListener()"></a>1.3 EventTarget.addEventListener()</h4><p><strong>所有 DOM 节点实例都有<code>addEventListener</code>方法</strong>，用来为该节点定义事件的监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, doSomething, <span class="literal">false</span>); <span class="comment">// 注意这里是函数名，不加圆括号</span></span><br></pre></td></tr></table></figure>

<p><code>addEventListener</code>方法的详细介绍，参见<code>EventTarget</code>章节。</p>
<h4 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h4><p>上面三种方法，</p>
<p>第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此<strong>不推荐使用</strong>。</p>
<p>第二种“元素节点的事件属性”的<strong>缺点</strong>在于，<strong>同一个事件只能定义一个监听函数</strong>，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，<strong>也不推荐使用</strong>。</p>
<p>第三种<code>EventTarget.addEventListener</code>是<strong>推荐的指定监听函数的方法</strong>。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h3 id="2、this-的指向-（指向元素节点）"><a href="#2、this-的指向-（指向元素节点）" class="headerlink" title="2、this 的指向 （指向元素节点）"></a>2、this 的指向 （指向元素节点）</h3><p><strong>监听函数内部的<code>this</code>指向触发事件的那个元素节点。（三种事件绑定的this全指向元素节点）</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行上面代码，点击后会输出<code>btn</code>。</p>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">btn.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h3 id="3、事件的传播（捕获、目标、冒泡）"><a href="#3、事件的传播（捕获、目标、冒泡）" class="headerlink" title="3、事件的传播（捕获、目标、冒泡）"></a>3、事件的传播（捕获、目标、冒泡）</h3><p>一个事件发生后，会<strong>在子元素和父元素之间传播</strong>（propagation）。这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“<strong>捕获阶段</strong>”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“<strong>目标阶段</strong>”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“<strong>冒泡阶段</strong>”（bubbling phase）。</li>
</ul>
<p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code> &lt;div&gt; </code>节点之中有一个<code> &lt;p&gt; </code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code> &lt;p&gt; </code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phases = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;capture&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&#x27;bubble&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>); <span class="comment">// true 表示在捕获阶段触发</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>); <span class="comment">// true 表示在捕获阶段触发</span></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);<span class="comment">// fasle 表示在冒泡阶段触发</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>); <span class="comment">// fasle 表示在冒泡阶段触发</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName; <span class="comment">// 当前目标对象的标签名</span></span><br><span class="line">  <span class="keyword">var</span> phase = phases[event.eventPhase]; <span class="comment">// 触发的阶段</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Tag: &#x27;&quot;</span> + tag + <span class="string">&quot;&#x27;. EventPhase: &#x27;&quot;</span> + phase + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击以后的结果</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;capture&#x27;  捕获阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27; 目标阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27; 目标阶段</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;bubble&#x27; 冒泡阶段</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>click</code>事件被触发了四次：<code> &lt;div&gt; </code>节点的捕获阶段和冒泡阶段各1次，<code> &lt;p&gt; </code>节点的目标阶段触发了2次。</p>
<ol>
<li>捕获阶段：事件从<code> &lt;div&gt; </code>向<code> &lt;p&gt; </code>传播时，触发<code> &lt;div&gt; </code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code> &lt;div&gt; </code>到达<code> &lt;p&gt; </code>时，触发<code> &lt;p&gt; </code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code> &lt;p&gt; </code>传回<code> &lt;div&gt; </code>时，再次触发<code> &lt;div&gt; </code>的<code>click</code>事件。</li>
</ol>
<p>其中，<code> &lt;p&gt; </code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code> &lt;p&gt; </code>会在<code>target</code>阶段有两次输出。</p>
<p><strong>注意</strong>，<strong>浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点</strong>（本例是<code> &lt;div&gt; </code>节点里面的<code> &lt;p&gt; </code>节点）。所以，**<code> &lt;p&gt; </code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。**</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">捕获阶段：</span><br><span class="line">window(浏览器对象)--&gt; document(文档对象) --&gt; html --&gt; body --&gt; div --&gt; p (点击目标，在目标阶段)</span><br><span class="line"></span><br><span class="line">冒泡阶段：</span><br><span class="line">p (点击目标，在目标阶段)--&gt; div --&gt; body --&gt; html --&gt; document(文档对象) --&gt; window(浏览器对象)</span><br></pre></td></tr></table></figure>



<h3 id="4、事件的代理"><a href="#4、事件的代理" class="headerlink" title="4、事件的代理"></a>4、事件的代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把<strong>子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理</strong>（delegation）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.tagName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123; <span class="comment">// 浏览器假定click嵌套最深的元素是目标元素</span></span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<h5 id="阻止事件冒泡-event-stopPropagation"><a href="#阻止事件冒泡-event-stopPropagation" class="headerlink" title="阻止事件冒泡 event.stopPropagation()"></a>阻止事件冒泡 event.stopPropagation()</h5><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation(); <span class="comment">// 该方法在事件对象event上</span></span><br><span class="line">&#125;, <span class="literal">true</span>); <span class="comment">// true表示在捕获阶段绑定事件监听函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>); <span class="comment">// false表示在冒泡阶段（默认值）绑定事件监听函数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，**<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code> &lt;p&gt; </code>节点的其他<code>click</code>事件的监听函数**。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 会触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>
<p>如果<strong>想要彻底取消该事件</strong>，不再触发后面所有<code>click</code>的监听函数，<strong>可以使用<code>stopImmediatePropagation()</code>方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h2 id="三、Event-对象"><a href="#三、Event-对象" class="headerlink" title="三、Event 对象"></a>三、Event 对象</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong>事件发生以后，会产生一个事件对象，作为参数传给监听函数</strong>。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><strong><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(type, options);<span class="comment">// 参数一，事件名称； 参数二，事件对象的配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象<strong>是否冒泡</strong>。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件<strong>是否可以被取消</strong>，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event( <span class="comment">// 创建一个新的事件实例</span></span><br><span class="line">  <span class="string">&#x27;look&#x27;</span>, <span class="comment">// 事件名称</span></span><br><span class="line">  &#123; <span class="comment">// 事件配置</span></span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>, <span class="comment">// 事件是否冒泡</span></span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">false</span> <span class="comment">// 事件是否可以被取消</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev); <span class="comment">// 触发ev实例，该实例是look事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Tag: &#x27;</span> + tag); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>); <span class="comment">// 该事件是在冒泡阶段监听函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">p.dispatchEvent(click); <span class="comment">// 给p发出一个click事件，该事件默认不会冒泡，因此不会触发父元素div的click事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2. 实例属性"></a>2. 实例属性</h3><h4 id="2-1-Event-bubbles-是否会冒泡，只读，Event-eventPhase-返回整数，表示事件所处阶段，只读"><a href="#2-1-Event-bubbles-是否会冒泡，只读，Event-eventPhase-返回整数，表示事件所处阶段，只读" class="headerlink" title="2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读"></a>2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读</h4><p><code>Event.bubbles</code>属性<strong>返回一个布尔值，表示当前事件是否会冒泡</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p>
<p><code>Event.eventPhase</code>属性<strong>返回一个整数常量，表示事件目前所处的阶段。该属性只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phase = event.eventPhase;</span><br></pre></td></tr></table></figure>

<p><code>Event.eventPhase</code>的返回值有四种可能。</p>
<ul>
<li>0，事件目前<strong>没有发生</strong>。</li>
<li>1，事件目前处于<strong>捕获阶段</strong>，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2，事件<strong>到达目标节点</strong>，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3，事件处于<strong>冒泡阶段</strong>，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
<h4 id="2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法"><a href="#2-2-Event-cancelable-是否可取消默认行为，Event-cancelBubble是否阻止冒泡，event-defaultPrevented-是否调用过取消默认行为方法" class="headerlink" title="2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法"></a>2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法</h4><p><code>Event.cancelable</code>属性<strong>返回一个布尔值，表示事件是否可以取消</strong>。该属性为<strong>只读</strong>属性，一般用来了解 Event 实例的特性。</p>
<p><strong>大多数浏览器的原生事件是可以取消的</strong>。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，<strong>默认是不可以取消的</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.cancelable  <span class="comment">// false 默认不可取消</span></span><br></pre></td></tr></table></figure>

<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;This event couldn\&#x27;t be canceled.&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以<strong>阻止事件的传播。</strong></p>
<p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件<strong>是否调用过<code>Event.preventDefault</code>方法。该属性只读。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.defaultPrevented) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;该事件已经取消了&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点"><a href="#2-3-Event-currentTarget当前正在通过的节点，Event-target目标节点" class="headerlink" title="2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点"></a>2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点</h4><p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的<strong>原始触发节点</strong>（<code>Event.target</code>），另一个是事件<strong>当前正在通过的节点</strong>（<code>Event.currentTarget</code>）。<strong>前者通常是后者的后代节点</strong>。</p>
<p><code>Event.currentTarget</code>属性返回事件<strong>当前所在的节点</strong>，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。<strong>随着事件的传播，这个属性的值会变</strong>。</p>
<p><code>Event.target</code>属性返回<strong>原始触发事件的那个节点</strong>，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
<p>事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;para&quot;&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不管点击 Hello 或 World，总是返回 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.currentTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击 Hello，返回 true</span></span><br><span class="line">  <span class="comment">// 点击 World，返回 false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;para&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, hide, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;em&gt;</code>是<code> &lt;p&gt; </code>的子节点，点击<code>&lt;em&gt;</code>或者点击<code> &lt;p&gt; </code>，都会导致监听函数执行。这时，<code>e.target</code>总是指向原始点击位置的那个节点，而<code>e.currentTarget</code>指向事件传播过程中正在经过的那个节点。由于监听函数只有事件经过时才会触发，所以<code>e.currentTarget</code>总是等同于监听函数内部的<code>this</code>。</p>
<h4 id="2-4-Event-type-事件类型（如：’click’）"><a href="#2-4-Event-type-事件类型（如：’click’）" class="headerlink" title="2.4 Event.type 事件类型（如：’click’）"></a>2.4 Event.type 事件类型（如：’click’）</h4><p><code>Event.type</code>属性<strong>返回一个字符串，表示事件类型</strong>。事件的类型是在生成事件的时候指定的。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.type <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-Event-timeStamp-相对于打开网页后的毫秒时间戳"><a href="#2-5-Event-timeStamp-相对于打开网页后的毫秒时间戳" class="headerlink" title="2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳"></a>2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳</h4><p><code>Event.timeStamp</code>属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.timeStamp <span class="comment">// 3683.6999999995896</span></span><br></pre></td></tr></table></figure>

<p>它的返回值有可能是整数，也有可能是小数（高精度时间戳），取决于浏览器的设置。</p>
<p>下面是一个<strong>计算鼠标移动速度的例子</strong>，显示每秒移动的像素数量。</p>
<h6 id="例子：计算鼠标移动速度"><a href="#例子：计算鼠标移动速度" class="headerlink" title="例子：计算鼠标移动速度"></a>例子：计算鼠标移动速度</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> previousX;</span><br><span class="line"><span class="keyword">var</span> previousY;</span><br><span class="line"><span class="keyword">var</span> previousT;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previousX !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousY !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">    previousT !== <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">var</span> deltaX = event.screenX - previousX;</span><br><span class="line">    <span class="keyword">var</span> deltaY = event.screenY - previousY;</span><br><span class="line">    <span class="keyword">var</span> deltaD = <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(deltaX, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(deltaY, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deltaT = event.timeStamp - previousT;</span><br><span class="line">    <span class="built_in">console</span>.log(deltaD / deltaT * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  previousX = event.screenX;</span><br><span class="line">  previousY = event.screenY;</span><br><span class="line">  previousT = event.timeStamp;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="2-6-Event-isTrusted-是否由真实用户行为产生的事件"><a href="#2-6-Event-isTrusted-是否由真实用户行为产生的事件" class="headerlink" title="2.6 Event.isTrusted 是否由真实用户行为产生的事件"></a>2.6 Event.isTrusted 是否由真实用户行为产生的事件</h4><p><code>Event.isTrusted</code>属性返回一个<strong>布尔值</strong>，表示<strong>该事件是否由真实的用户行为产生</strong>。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">evt.isTrusted <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>evt</code>对象是脚本产生的，所以<code>isTrusted</code>属性返回<code>false</code>。</p>
<h4 id="2-7-Event-detail-事件的细节（单击or双击等）"><a href="#2-7-Event-detail-事件的细节（单击or双击等）" class="headerlink" title="2.7 Event.detail 事件的细节（单击or双击等）"></a>2.7 Event.detail 事件的细节（单击or双击等）</h4><p><code>Event.detail</code>属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。比如，对于<code>click</code>和<code>dblclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveDetails</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail); <span class="comment">// 快速点击的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>).onclick = giveDetails;</span><br></pre></td></tr></table></figure>



<h3 id="3、实例方法"><a href="#3、实例方法" class="headerlink" title="3、实例方法"></a>3、实例方法</h3><h4 id="3-1-Event-preventDefault-取消浏览器对当前事件的默认行为"><a href="#3-1-Event-preventDefault-取消浏览器对当前事件的默认行为" class="headerlink" title="3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为"></a>3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为</h4><p><code>Event.preventDefault</code>方法<strong>取消浏览器对当前事件的默认行为</strong>。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p>
<p><strong>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播</strong>。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;checkbox&quot; id=&quot;my-checkbox&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-checkbox&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123; e.preventDefault(); &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<p>利用这个方法，可以为文本输入框设置校验条件。如果用户的输入不符合条件，就无法将字符输入文本框。</p>
<h6 id="例子：只能输入字母的输入框"><a href="#例子：只能输入字母的输入框" class="headerlink" title="例子：只能输入字母的输入框"></a>例子：只能输入字母的输入框</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;my-input&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-input&#x27;</span>);</span><br><span class="line">input.addEventListener(<span class="string">&#x27;keypress&#x27;</span>, checkName, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.charCode &lt; <span class="number">97</span> || e.charCode &gt; <span class="number">122</span>) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h4 id="3-2-Event-stopPropagation-阻止事件传播"><a href="#3-2-Event-stopPropagation-阻止事件传播" class="headerlink" title="3.2 Event.stopPropagation() 阻止事件传播"></a>3.2 Event.stopPropagation() 阻止事件传播</h4><p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation(); <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, stopEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>
<h4 id="3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用"><a href="#3-3-Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用" class="headerlink" title="3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用"></a>3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用</h4><p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l2</span>(<span class="params">e</span>)</span>&#123; <span class="comment">// 不会被调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, l1, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, l2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h4 id="3-4-Event-composedPath-数组，目标和冒泡的节点"><a href="#3-4-Event-composedPath-数组，目标和冒泡的节点" class="headerlink" title="3.4 Event.composedPath() 数组，目标和冒泡的节点"></a>3.4 Event.composedPath() 数组，目标和冒泡的节点</h4><p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.composedPath());</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// [p, div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
<h2 id="四、鼠标事件"><a href="#四、鼠标事件" class="headerlink" title="四、鼠标事件"></a>四、鼠标事件</h2><h3 id="1、鼠标事件的种类"><a href="#1、鼠标事件的种类" class="headerlink" title="1、鼠标事件的种类"></a>1、鼠标事件的种类</h3><p>鼠标事件指与鼠标相关的事件，继承了<code>MouseEvent</code>接口。具体的事件主要有以下一些。</p>
<ul>
<li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。<strong>【单击】</strong></li>
<li><code>dblclick</code>：在同一个元素上双击鼠标时触发。<strong>【双击】</strong></li>
<li><code>mousedown</code>：按下鼠标键时触发。<strong>【按下】</strong></li>
<li><code>mouseup</code>：释放按下的鼠标键时触发。<strong>【抬起】</strong></li>
<li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。<strong>【经过（多次）】</strong></li>
<li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。<strong>【进入（单次）】</strong></li>
<li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。<strong>【进入+子节点】</strong></li>
<li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。<strong>【离开（单次）】</strong></li>
<li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点会触发这个事件（详见后文）。<strong>【离开+子节点】</strong></li>
<li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。<strong>【右键】</strong></li>
<li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。<strong>【滚轮】</strong></li>
</ul>
<p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span></span><br><span class="line"><span class="comment">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span></span><br><span class="line"><span class="comment">// 只有离开 ul 节点时，触发一次 mouseleave</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p>
<h3 id="2、MouseEvent-接口概述"><a href="#2、MouseEvent-接口概述" class="headerlink" title="2、MouseEvent 接口概述"></a>2、MouseEvent 接口概述</h3><p><code>MouseEvent</code>接口代表<strong>所有鼠标事件所产生的对象都是<code>MouseEvent</code>实例</strong>。此外，<strong>滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</strong></p>
<p><code>MouseEvent</code>接口<strong>继承了<code>Event</code>接口</strong>，所以拥有<code>Event</code>的所有属性和方法。它还有自己的属性和方法。</p>
<p>浏览器<strong>原生提供一个<code>MouseEvent</code>构造函数</strong>，用于新建一个<code>MouseEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(type, options);<span class="comment">// 参数一，事件名称字符串；参数二，事件配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>MouseEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>
<ul>
<li><code>screenX</code>：数值，鼠标相对于<strong>屏幕</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>screenY</code>：数值，鼠标相对于<strong>屏幕</strong>的垂直位置（单位像素），其他与<code>screenX</code>相同。</li>
<li><code>clientX</code>：数值，鼠标相对于<strong>程序窗口</strong>的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>clientY</code>：数值，鼠标相对于<strong>程序窗口</strong>的垂直位置（单位像素），其他与<code>clientX</code>相同。</li>
<li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否同时按下 Meta 键（win键），默认值为<code>false</code>。</li>
<li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li>
<li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li>
<li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&#x27;click2&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line">cb.addEventListener(<span class="string">&#x27;click2&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 绑定事件监听函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">22</span>) <span class="comment">// 被执行</span></span><br><span class="line">&#125;)</span><br><span class="line">cb.dispatchEvent(event);<span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个鼠标点击事件，并触发该事件。</p>
<h3 id="3、MouseEvent-接口的实例属性"><a href="#3、MouseEvent-接口的实例属性" class="headerlink" title="3、MouseEvent 接口的实例属性"></a>3、MouseEvent 接口的实例属性</h3><h4 id="3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey"><a href="#3-1-MouseEvent-altKey，MouseEvent-ctrlKey，MouseEvent-metaKey，MouseEvent-shiftKey" class="headerlink" title="3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey"></a>3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</h4><p><code>MouseEvent.altKey</code>、<code>MouseEvent.ctrlKey</code>、<code>MouseEvent.metaKey</code>、<code>MouseEvent.shiftKey</code>这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是<strong>只读</strong>属性。</p>
<ul>
<li><code>altKey</code>属性：Alt 键</li>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onclick=&quot;showKey(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showKey</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ALT key pressed: &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CTRL key pressed: &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;META key pressed: &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;SHIFT key pressed: &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击网页会输出是否同时按下对应的键。</p>
<h4 id="3-2-MouseEvent-button-鼠标的哪个键，MouseEvent-buttons同时按哪些键"><a href="#3-2-MouseEvent-button-鼠标的哪个键，MouseEvent-buttons同时按哪些键" class="headerlink" title="3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键"></a>3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键</h4><p><code>MouseEvent.button</code>属性返回<strong>一个数值，表示事件发生时按下了鼠标的哪个键</strong>。该属性<strong>只读</strong>。</p>
<ul>
<li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</li>
<li>1：按下辅助键（通常是中键或者滚轮键）。</li>
<li>2：按下次键（通常是右键）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button onmouseup=&quot;whichButton(event)&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> whichButton = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.button) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Left button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Middle button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Right button clicked.&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Unexpected code: &#x27;</span> + e.button);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.buttons</code>属性返回一个<strong>三个比特位的值</strong>，表示<strong>同时按下了哪些键</strong>。它<strong>用来处理同时按下多个鼠标键的情况</strong>。该属性<strong>只读</strong>。</p>
<ul>
<li>1：二进制为<code>001</code>（十进制的1），表示按下左键。</li>
<li>2：二进制为<code>010</code>（十进制的2），表示按下右键。</li>
<li>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</li>
</ul>
<p>同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; <span class="comment">// 注意，用click时一直都是0</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.buttons)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 未按下任何键时是 0</span></span><br><span class="line"><span class="comment">// 按下左键 1  （001）</span></span><br><span class="line"><span class="comment">// 按下右键 2  （010）</span></span><br><span class="line"><span class="comment">// 按下中键 4  （100）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下左键和右键 3  （011）</span></span><br><span class="line"><span class="comment">// 按下左键和中键 5  （101）</span></span><br><span class="line"><span class="comment">// 按下右键和中键 6  （110）</span></span><br><span class="line"><span class="comment">// 按下左、中、右键 7  （111）</span></span><br></pre></td></tr></table></figure>





<h4 id="3-3-MouseEvent-clientX-相对浏览器X坐标，MouseEvent-clientY-相对浏览器Y坐标"><a href="#3-3-MouseEvent-clientX-相对浏览器X坐标，MouseEvent-clientY-相对浏览器Y坐标" class="headerlink" title="3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标"></a>3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标</h4><p><code>MouseEvent.clientX</code>属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;clientX value: &#x27;</span> + evt.clientX + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;clientY value: &#x27;</span> + evt.clientY + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个属性还分别有一个**别名<code>MouseEvent.x</code>和<code>MouseEvent.y</code>**。</p>
<h4 id="3-4-MouseEvent-movementX-上一个鼠标经过事件的X距离，MouseEvent-movementY-上一个鼠标经过事件的Y距离"><a href="#3-4-MouseEvent-movementX-上一个鼠标经过事件的X距离，MouseEvent-movementY-上一个鼠标经过事件的Y距离" class="headerlink" title="3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离"></a>3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离</h4><p><code>MouseEvent.movementX</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementX = currentEvent.screenX - previousEvent.screenX</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent.movementY</code>属性返回当前位置与上一个<code>mousemove</code>事件之间的垂直距离（单位像素）。数值上，它等于下面的计算公式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。</span><br></pre></td></tr></table></figure>

<p>这两个属性都是<strong>只读</strong>属性。</p>
<h4 id="3-5-MouseEvent-screenX-相对屏幕X坐标，MouseEvent-screenY-相对屏幕Y坐标"><a href="#3-5-MouseEvent-screenX-相对屏幕X坐标，MouseEvent-screenY-相对屏幕Y坐标" class="headerlink" title="3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标"></a>3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标</h4><p><code>MouseEvent.screenX</code>属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），<code>MouseEvent.screenY</code>属性返回垂直坐标。这两个属性都是<strong>只读</strong>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onmousedown=&quot;showCoords(event)&quot;&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCoords</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&#x27;screenX value: &#x27;</span> + evt.screenX + <span class="string">&#x27;\n&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;screenY value: &#x27;</span> + evt.screenY + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-MouseEvent-offsetX-偏移量X，MouseEvent-offsetY-偏移量Y"><a href="#3-6-MouseEvent-offsetX-偏移量X，MouseEvent-offsetY-偏移量Y" class="headerlink" title="3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y"></a>3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y</h4><p><code>MouseEvent.offsetX</code>属性返回鼠标位置与目标节点左侧的<code>padding</code>边缘的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回与目标节点上方的<code>padding</code>边缘的垂直距离。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    p &#123;</span></span><br><span class="line"><span class="comment">      width: 100px;</span></span><br><span class="line"><span class="comment">      height: 100px;</span></span><br><span class="line"><span class="comment">      padding: 100px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">  &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetX); <span class="comment">// 包含padding</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.offsetY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，鼠标如果在<code>p</code>元素的中心位置点击，会返回<code>150 150</code>。因此中心位置距离左侧和上方的<code>padding</code>边缘，等于<code>padding</code>的宽度（100像素）加上元素内容区域一半的宽度（50像素）。</p>
<h4 id="3-7-MouseEvent-pageX-文档X坐标，MouseEvent-pageY-文档Y坐标"><a href="#3-7-MouseEvent-pageX-文档X坐标，MouseEvent-pageY-文档Y坐标" class="headerlink" title="3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标"></a>3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标</h4><p><code>MouseEvent.pageX</code>属性返回鼠标位置与文档左侧边缘的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的<strong>返回值都包括文档不可见的部分</strong>。这两个属性都是<strong>只读</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    body &#123;</span></span><br><span class="line"><span class="comment">      height: 2000px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX);</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageY);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，页面高度为2000像素，会产生垂直滚动条。滚动到页面底部，点击鼠标输出的<code>pageY</code>值会接近2000。</p>
<h4 id="3-8-MouseEvent-relatedTarget-事件的相关节点"><a href="#3-8-MouseEvent-relatedTarget-事件的相关节点" class="headerlink" title="3.8 MouseEvent.relatedTarget 事件的相关节点"></a>3.8 MouseEvent.relatedTarget 事件的相关节点</h4><p><code>MouseEvent.relatedTarget</code>属性<strong>返回事件的相关节点</strong>。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性<strong>只读</strong>。</p>
<p>下表列出不同事件的<code>target</code>属性值和<code>relatedTarget</code>属性值义。</p>
<table>
<thead>
<tr>
<th align="left">事件名称</th>
<th align="left">target 属性</th>
<th align="left">relatedTarget 属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">focusin</td>
<td align="left">接受焦点的节点</td>
<td align="left">丧失焦点的节点</td>
</tr>
<tr>
<td align="left">focusout</td>
<td align="left">丧失焦点的节点</td>
<td align="left">接受焦点的节点</td>
</tr>
<tr>
<td align="left">mouseenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">mouseleave</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseout</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
<tr>
<td align="left">mouseover</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragenter</td>
<td align="left">将要进入的节点</td>
<td align="left">将要离开的节点</td>
</tr>
<tr>
<td align="left">dragexit</td>
<td align="left">将要离开的节点</td>
<td align="left">将要进入的节点</td>
</tr>
</tbody></table>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;div id=&quot;outer&quot; style=&quot;height:50px;width:50px;border-width:1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;inner&quot; style=&quot;height:25px;width:25px;border:1px solid black;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;inner&#x27;</span>);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;进入&#x27;</span> + event.target.id + <span class="string">&#x27; 离开&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;进入&#x27;</span> + event.target.id + <span class="string">&#x27; 离开&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;离开&#x27;</span> + event.target.id + <span class="string">&#x27; 进入&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line">inner.addEventListener(<span class="string">&quot;mouseleave&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;离开&#x27;</span> + event.target.id + <span class="string">&#x27; 进入&#x27;</span> + event.relatedTarget.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 outer 进入inner，输出</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"><span class="comment">// 进入inner 离开outer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标从 inner进入 outer，输出</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br><span class="line"><span class="comment">// 离开inner 进入outer</span></span><br></pre></td></tr></table></figure>



<h3 id="4、MouseEvent-接口的实例方法"><a href="#4、MouseEvent-接口的实例方法" class="headerlink" title="4、MouseEvent 接口的实例方法"></a>4、MouseEvent 接口的实例方法</h3><h4 id="4-1-MouseEvent-getModifierState-是否按下指定功能键"><a href="#4-1-MouseEvent-getModifierState-是否按下指定功能键" class="headerlink" title="4.1 MouseEvent.getModifierState() 是否按下指定功能键"></a>4.1 MouseEvent.getModifierState() 是否按下指定功能键</h4><p><code>MouseEvent.getModifierState</code>方法<strong>返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#Modifier_keys_on_Gecko">功能键</a>的字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.getModifierState(<span class="string">&#x27;CapsLock&#x27;</span>));</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码可以了解用户是否按下了大写键。</p>
<h3 id="5、WheelEvent-接口-（滚轮）"><a href="#5、WheelEvent-接口-（滚轮）" class="headerlink" title="5、WheelEvent 接口 （滚轮）"></a>5、WheelEvent 接口 （滚轮）</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p><strong>WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象</strong>。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>
<p>浏览器原生提供<code>WheelEvent()</code>构造函数，用来生成<code>WheelEvent</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wheelEvent = <span class="keyword">new</span> WheelEvent(type, options);</span><br></pre></td></tr></table></figure>

<p><code>WheelEvent()</code>构造函数可以接受两个参数，第一个是字符串，表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code>。第二个参数是事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</p>
<ul>
<li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
<li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
<li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
<li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li>
</ul>
<h4 id="5-2-实例属性"><a href="#5-2-实例属性" class="headerlink" title="5.2 实例属性"></a>5.2 实例属性</h4><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>
<p>下面的属性都是只读属性。</p>
<ul>
<li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
<li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
<li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
<li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</li>
</ul>
<h2 id="五、键盘事件"><a href="#五、键盘事件" class="headerlink" title="五、键盘事件"></a>五、键盘事件</h2><h3 id="1、键盘事件的种类"><a href="#1、键盘事件的种类" class="headerlink" title="1、键盘事件的种类"></a>1、键盘事件的种类</h3><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。<strong>【按下】</strong></li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。<strong>【按下有值的键】</strong></li>
<li><code>keyup</code>：松开键盘时触发该事件。<strong>【松开】</strong></li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<h3 id="2、KeyboardEvent-接口概述"><a href="#2、KeyboardEvent-接口概述" class="headerlink" title="2、KeyboardEvent 接口概述"></a>2、KeyboardEvent 接口概述</h3><p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。这个接口<strong>继承了<code>Event</code>接口</strong>，并且定义了自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>KeyboardEvent</code>构造函数，用来新建键盘事件的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options) <span class="comment">// 参数一，事件类型；参数二，事件配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示<strong>事件类型</strong>；第二个参数是一个<strong>事件配置对象</strong>，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。<strong>【键名】</strong></li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。<strong>【键码】</strong></li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<h3 id="3、KeyboardEvent-的实例属性"><a href="#3、KeyboardEvent-的实例属性" class="headerlink" title="3、KeyboardEvent 的实例属性"></a>3、KeyboardEvent 的实例属性</h3><h4 id="3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey-【是否按下对应键，布尔值】"><a href="#3-1-KeyboardEvent-altKey，KeyboardEvent-ctrlKey，KeyboardEvent-metaKey，KeyboardEvent-shiftKey-【是否按下对应键，布尔值】" class="headerlink" title="3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】"></a>3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】</h4><p>以下属性都是<strong>只读</strong>属性，返回一个布尔值，表示是否按下对应的键。</p>
<ul>
<li><code>KeyboardEvent.altKey</code>：是否按下 Alt 键</li>
<li><code>KeyboardEvent.ctrlKey</code>：是否按下 Ctrl 键</li>
<li><code>KeyboardEvent.metaKey</code>：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</li>
<li><code>KeyboardEvent.shiftKey</code>：是否按下 Shift 键</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showChar</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ALT: &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CTRL: &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Meta: &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Shift: &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;keydown&#x27;</span>, showChar, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3-2-KeyboardEvent-code-键码"><a href="#3-2-KeyboardEvent-code-键码" class="headerlink" title="3.2 KeyboardEvent.code 键码"></a>3.2 KeyboardEvent.code 键码</h4><p><code>KeyboardEvent.code</code>属性<strong>返回一个字符串，表示当前按下的键的字符串形式</strong>。该属性<strong>只读</strong>。</p>
<p>下面是一些常用键的字符串形式，其他键请查<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code#Code_values">文档</a>。</p>
<ul>
<li>数字键0 - 9：返回<code>digital0</code> - <code>digital9</code></li>
<li>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></li>
<li>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></li>
<li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li>
<li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li>
<li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li>
<li>Ctrl 键：返回<code>ControlLeft</code>或<code>ControlRight</code></li>
</ul>
<h4 id="3-3-KeyboardEvent-key-键名"><a href="#3-3-KeyboardEvent-key-键名" class="headerlink" title="3.3 KeyboardEvent.key 键名"></a>3.3 KeyboardEvent.key 键名</h4><p><code>KeyboardEvent.key</code>属性<strong>返回一个字符串，表示按下的键名</strong>。该属性<strong>只读</strong>。</p>
<p>如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。</p>
<p>如果按下的键代表不可打印的特殊字符，则返回预定义的键值，比如 Backspace，Tab，Enter，Shift，Control，Alt，CapsLock，Esc，Spacebar，PageUp，PageDown，End，Home，Left，Right，Up，Down，PrintScreen，Insert，Del，Win，F1～F12，NumLock，Scroll 等。</p>
<p>如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回<code>a</code>；按下 Shift + a，则返回大写的<code>A</code>。</p>
<p>如果无法识别键名，返回字符串<code>Unidentified</code>。</p>
<h4 id="3-4-KeyboardEvent-location-键处于哪个位置，整数"><a href="#3-4-KeyboardEvent-location-键处于哪个位置，整数" class="headerlink" title="3.4 KeyboardEvent.location 键处于哪个位置，整数"></a>3.4 KeyboardEvent.location 键处于哪个位置，整数</h4><p><code>KeyboardEvent.location</code>属性<strong>返回一个整数，表示按下的键处在键盘的哪一个区域</strong>。它可能取以下值。</p>
<ul>
<li><p>0：处在键盘的主区域，或者无法判断处于哪一个区域。</p>
</li>
<li><p>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
</li>
<li><p>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</p>
</li>
<li><p>3：处在数字小键盘。</p>
</li>
</ul>
<h4 id="3-5-KeyboardEvent-repeat-是否长按"><a href="#3-5-KeyboardEvent-repeat-是否长按" class="headerlink" title="3.5 KeyboardEvent.repeat 是否长按"></a>3.5 KeyboardEvent.repeat 是否长按</h4><p><code>KeyboardEvent.repeat</code>返回一个<strong>布尔值，代表该键是否被按着不放</strong>，以便判断是否重复这个键，即浏览器会持续触发<code>keydown</code>和<code>keypress</code>事件，直到用户松开手为止。</p>
<h3 id="4、KeyboardEvent-的实例方法"><a href="#4、KeyboardEvent-的实例方法" class="headerlink" title="4、KeyboardEvent 的实例方法"></a>4、KeyboardEvent 的实例方法</h3><h4 id="4-1-KeyboardEvent-getModifierState-是否按下指定功能键"><a href="#4-1-KeyboardEvent-getModifierState-是否按下指定功能键" class="headerlink" title="4.1 KeyboardEvent.getModifierState() 是否按下指定功能键"></a>4.1 KeyboardEvent.getModifierState() 是否按下指定功能键</h4><p><code>KeyboardEvent.getModifierState()</code>方法返回一个<strong>布尔值，表示是否按下或激活指定的功能键</strong>。它的常用参数如下。</p>
<ul>
<li><code>Alt</code>：Alt 键</li>
<li><code>CapsLock</code>：大写锁定键</li>
<li><code>Control</code>：Ctrl 键</li>
<li><code>Meta</code>：Meta 键</li>
<li><code>NumLock</code>：数字键盘开关键</li>
<li><code>Shift</code>：Shift 键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Control&#x27;</span>) +</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Alt&#x27;</span>) +</span><br><span class="line">  event.getModifierState(<span class="string">&#x27;Meta&#x27;</span>) &gt; <span class="number">1</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只要<code>Control</code>、<code>Alt</code>、<code>Meta</code>里面，同时按下任意两个或两个以上的键就返回。</p>
<h2 id="六、进度事件"><a href="#六、进度事件" class="headerlink" title="六、进度事件"></a>六、进度事件</h2><h3 id="1、进度事件的种类"><a href="#1、进度事件的种类" class="headerlink" title="1、进度事件的种类"></a>1、进度事件的种类</h3><p><strong>进度事件用来描述资源加载的进度</strong>，主要由 AJAX 请求、<code> &lt;img&gt; </code>、<code> &lt;audio&gt; </code>、<code> &lt;video&gt; </code>、<code> &lt;style&gt; </code>、<code>&lt;link&gt;</code>等外部资源的加载触发，继承了<code>ProgressEvent</code>接口。它主要包含以下几种<strong>事件</strong>。</p>
<ul>
<li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。<strong>【中止加载】</strong></li>
<li><code>error</code>：由于错误导致外部资源无法加载时触发。<strong>【加载错误】</strong></li>
<li><code>load</code>：外部资源加载成功时触发。<strong>【加载成功】</strong></li>
<li><code>loadstart</code>：外部资源开始加载时触发。<strong>【开始加载】</strong></li>
<li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。<strong>【停止加载】</strong></li>
<li><code>progress</code>：外部资源加载过程中不断触发。<strong>【加载中，不断触发】</strong></li>
<li><code>timeout</code>：加载超时时触发。<strong>【加载超时】</strong></li>
</ul>
<p>注意，除了资源下载，<strong>文件上传也存在这些事件</strong>。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">// 加载成功</span></span><br><span class="line">  image.classList.add(<span class="string">&#x27;finished&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">// 加载出错</span></span><br><span class="line">  image.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>
<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.complete) &#123; <span class="comment">// 是否加载完成</span></span><br><span class="line">  loaded();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  image.addEventListener(<span class="string">&#x27;load&#x27;</span>, loaded); <span class="comment">// 加载成功事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code> &lt;img&gt; </code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/wrong/url&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, loadEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束，成功失败未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>
<p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p>
<h3 id="2、ProgressEvent-接口"><a href="#2、ProgressEvent-接口" class="headerlink" title="2、ProgressEvent 接口"></a>2、ProgressEvent 接口</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><code>ProgressEvent</code>接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<code> &lt;img&gt; </code>、<code> &lt;video&gt; </code>、<code> &lt;style&gt; </code>、<code>&lt;link&gt;</code>等外部资源加载。进度相关的事件都继承了这个接口。<strong>这个接口继承了Event接口。</strong></p>
<p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ProgressEvent(type, options) <span class="comment">// 参数一，事件类型；参数二，配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>
<ul>
<li><code>lengthComputable</code>：布尔值，表示加载的<strong>总量是否可以计算</strong>，默认是<code>false</code>。</li>
<li><code>loaded</code>：整数，表示<strong>已经加载的量</strong>，默认是<code>0</code>。</li>
<li><code>total</code>：整数，表示<strong>需要加载的总量</strong>，默认是<code>0</code>。</li>
</ul>
<h4 id="2-2-ProgressEvent的实例属性。"><a href="#2-2-ProgressEvent的实例属性。" class="headerlink" title="2.2 ProgressEvent的实例属性。"></a>2.2 ProgressEvent的实例属性。</h4><ul>
<li><code>ProgressEvent.lengthComputable</code> <strong>总量是否可以计算</strong></li>
<li><code>ProgressEvent.loaded</code> <strong>已加载的量</strong></li>
<li><code>ProgressEvent.total </code> <strong>需要加载的总量</strong></li>
</ul>
<p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ProgressEvent(<span class="string">&#x27;load&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">lengthComputable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">total</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已经加载：&#x27;</span> + (e.loaded / e.total) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(p);</span><br><span class="line"><span class="comment">// 已经加载：30%</span></span><br></pre></td></tr></table></figure>

<p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>); <span class="comment">// 加载中</span></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>); <span class="comment">// 加载成功</span></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>); <span class="comment">// 加载错误</span></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>); <span class="comment">// 中止加载</span></span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 加载中</span></span><br><span class="line">  <span class="keyword">if</span> (e.lengthComputable) &#123; <span class="comment">// 是否可以计算总量</span></span><br><span class="line">    <span class="keyword">var</span> percentComplete = e.loaded / e.total; <span class="comment">// 加载进度计算</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不能计算进度&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferComplete</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 加载成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFailed</span>(<span class="params">evt</span>) </span>&#123; <span class="comment">// 加载错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输过程中发生错误&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferCanceled</span>(<span class="params">evt</span>) </span>&#123; <span class="comment">// 中止加载</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;用户取消了传输&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是下载过程的进度事件，还存在<strong>上传过程的进度事件</strong>。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>



<h2 id="七、表单事件"><a href="#七、表单事件" class="headerlink" title="七、表单事件"></a>七、表单事件</h2><h3 id="1、表单事件的种类"><a href="#1、表单事件的种类" class="headerlink" title="1、表单事件的种类"></a>1、表单事件的种类</h3><h4 id="1-1-input-事件-（值发生变化触发，会连续）"><a href="#1-1-input-事件-（值发生变化触发，会连续）" class="headerlink" title="1.1 input 事件 （值发生变化触发，会连续）"></a>1.1 input 事件 （值发生变化触发，会连续）</h4><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的<strong>值发生变化时触发</strong>。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p>
<p><code>input</code>事件的一个特点，就是<strong>会连续触发</strong>，比如<strong>用户每按下一次按键，就会触发一次<code>input</code>事件</strong>。</p>
<p><code>input</code>事件对象<strong>继承了<code>InputEvent</code>接口</strong>。</p>
<p>该事件跟<code>change</code>事件很像，不同之处在于**<code>input</code>事件在元素的值发生变化后立即发生<strong>，</strong>而<code>change</code>在元素失去焦点时发生<strong>，而内容此时可能已经变化多次。也就是说，如果有连续变化，</strong><code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。**</p>
<p>下面是<code>&lt;select&gt;</code>元素的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;mySelect&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inputHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySelect = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#mySelect&#x27;</span>);</span><br><span class="line">mySelect.addEventListener(<span class="string">&#x27;input&#x27;</span>, inputHandler);</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变下拉框选项时，会触发<code>input</code>事件，从而执行回调函数<code>inputHandler</code>。</p>
<h4 id="1-2-select-事件-（选中文本时触发）"><a href="#1-2-select-事件-（选中文本时触发）" class="headerlink" title="1.2 select 事件 （选中文本时触发）"></a>1.2 select 事件 （选中文本时触发）</h4><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面<strong>选中文本时触发</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">elem.addEventListener(<span class="string">&#x27;select&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.type); <span class="comment">// &quot;select&quot; 事件类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _target = e.target;</span><br><span class="line">  <span class="built_in">console</span>.log(_target.value); <span class="comment">// 文本框的全部值</span></span><br><span class="line">  <span class="built_in">console</span>.log(_target.selectionDirection); <span class="comment">// 选择的方向：&#x27;forward&#x27;正向、&#x27;backward&#x27;反向</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(_target.selectionStart); <span class="comment">// 开始选择的索引</span></span><br><span class="line">  <span class="built_in">console</span>.log(_target.selectionEnd); <span class="comment">// 结束选择的索引</span></span><br><span class="line">  <span class="comment">// 注意：开始和结束索引是不分选择方向的，开始的索引一直是靠前的</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(_target.value.slice(_target.selectionStart, _target.selectionEnd)) <span class="comment">// 选中的那部分字符串</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p>
<h4 id="1-3-change-事件-（值发生变化时触发，单次）"><a href="#1-3-change-事件-（值发生变化时触发，单次）" class="headerlink" title="1.3 change 事件 （值发生变化时触发，单次）"></a>1.3 change 事件 （值发生变化时触发，单次）</h4><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的<strong>值发生变化时触发</strong>。它与<code>input</code>事件的最大不同，就是<strong>不会连续触发，只有当全部修改完成时才会触发</strong>，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;chocolate&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;strawberry&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;vanilla&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeEventHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果比较一下上面<code>input</code>事件的例子，你会发现对于<code>&lt;select&gt;</code>元素来说，<code>input</code>和<code>change</code>事件基本是等价的。</p>
<h4 id="1-4-invalid-事件-（表单提交不满足条件触发）"><a href="#1-4-invalid-事件-（表单提交不满足条件触发）" class="headerlink" title="1.4 invalid 事件 （表单提交不满足条件触发）"></a>1.4 invalid 事件 （表单提交不满足条件触发）</h4><p><strong>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">oninvalid</span>=<span class="string">&quot;console.log(&#x27;invalid input&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p>
<h4 id="1-5-reset-事件（重置），submit-事件（提交）"><a href="#1-5-reset-事件（重置），submit-事件（提交）" class="headerlink" title="1.5 reset 事件（重置），submit 事件（提交）"></a>1.5 reset 事件（重置），submit 事件（提交）</h4><p><code>reset</code>事件当<strong>表单重置（所有表单成员变回默认值）时触发。</strong></p>
<p><code>submit</code>事件当<strong>表单数据向服务器提交时触发</strong>。</p>
<p>注意，<strong>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上</strong>，因为提交的是表单，而不是表单成员。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onreset</span>=<span class="string">&quot;console.log(&#x27;触发了重置事件&#x27;)&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;console.log(&#x27;触发了提交事件&#x27;)&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">action</span>=<span class="string">&quot;html_form_action.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Duck&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2、InputEvent-接口（input事件的实例）"><a href="#2、InputEvent-接口（input事件的实例）" class="headerlink" title="2、InputEvent 接口（input事件的实例）"></a>2、InputEvent 接口（input事件的实例）</h3><p><strong><code>InputEvent</code>接口主要用来描述<code>input</code>事件的实例</strong>。该接口<strong>继承了<code>Event</code>接口</strong>，还定义了一些自己的实例属性和实例方法。</p>
<p>浏览器原生提供<code>InputEvent()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InputEvent(type, options) <span class="comment">// 参数一，事件名称；参数二，配置对象</span></span><br></pre></td></tr></table></figure>

<p><code>InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示<strong>事件名称</strong>，该参数是必需的。第二个参数是一个<strong>配置对象</strong>，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code>Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>
<ul>
<li><code>inputType</code>：字符串，表示<strong>发生变更的类型</strong>（详见下文）。</li>
<li><code>data</code>：字符串，表示<strong>插入的字符串</strong>。如果没有插入的字符串（比如删除操作），则返回<code>null</code>或空字符串。</li>
<li><code>dataTransfer</code>：返回一个 <strong>DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效</strong>。</li>
</ul>
<p><code>InputEvent</code>的实例属性主要就是上面三个属性，这三个实例属性都是<strong>只读的</strong>。</p>
<h4 id="（1）InputEvent-data-变动的那部分内容"><a href="#（1）InputEvent-data-变动的那部分内容" class="headerlink" title="（1）InputEvent.data 变动的那部分内容"></a>（1）InputEvent.data 变动的那部分内容</h4><p><code>InputEvent.data</code>属性返回一个字符串，表示<strong>变动的内容</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;myInput&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myInput&#x27;</span>);</span><br><span class="line">input.addEventListener(<span class="string">&#x27;input&#x27;</span>, myFunction, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果手动在输入框里面输入<code>abc</code>，控制台会先输出<code>a</code>，再在下一行输出<code>b</code>，再在下一行输出<code>c</code>。然后选中<code>abc</code>，一次性将它们删除，控制台会输出<code>null</code>或一个空字符串。</p>
<h4 id="（2）InputEvent-inputType-变更类型"><a href="#（2）InputEvent-inputType-变更类型" class="headerlink" title="（2）InputEvent.inputType 变更类型"></a>（2）InputEvent.inputType 变更类型</h4><p><code>InputEvent.inputType</code>属性返回一个字符串，表示字符串<strong>发生变更的类型</strong>。</p>
<p>对于常见情况，Chrome 浏览器的返回值如下。完整列表可以参考<a target="_blank" rel="noopener" href="https://w3c.github.io/input-events/index.html#dom-inputevent-inputtype">文档</a>。</p>
<ul>
<li>手动插入文本：<code>insertText</code></li>
<li>粘贴插入文本：<code>insertFromPaste</code></li>
<li>向后删除：<code>deleteContentBackward</code></li>
<li>向前删除：<code>deleteContentForward</code></li>
</ul>
<h4 id="（3）InputEvent-dataTransfer"><a href="#（3）InputEvent-dataTransfer" class="headerlink" title="（3）InputEvent.dataTransfer"></a>（3）InputEvent.dataTransfer</h4><p><code>InputEvent.dataTransfer</code>属性<strong>返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（<code>insertFromDrop</code>）时才有效</strong>。</p>
<h2 id="八、触摸事件"><a href="#八、触摸事件" class="headerlink" title="八、触摸事件"></a>八、触摸事件</h2><h3 id="1、触摸操作概述"><a href="#1、触摸操作概述" class="headerlink" title="1、触摸操作概述"></a>1、触摸操作概述</h3><p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点的实例</li>
<li>TouchList：多个触摸点集合的实例</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括<strong>位置、大小、形状、压力、目标元素等属性</strong>。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，<strong>触摸事件和鼠标事件同时触发</strong>，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，<strong>可以用<code>event.preventDefault</code>方法阻止发出鼠标事件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TouchEvent &#123;<span class="attr">isTrusted</span>: <span class="literal">true</span>, <span class="attr">touches</span>: TouchList, <span class="attr">targetTouches</span>: TouchList, <span class="attr">changedTouches</span>: TouchList, <span class="attr">altKey</span>: <span class="literal">false</span>, …&#125; <span class="comment">// TouchEvent接口 ，继承Event接口属性和方法</span></span><br><span class="line">    <span class="attr">altKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">bubbles</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">cancelBubble</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">changedTouches</span>: TouchList <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">            <span class="number">0</span>: Touch <span class="comment">// Touch 接口 （单个触摸点）</span></span><br><span class="line">                <span class="attr">clientX</span>: <span class="number">232</span></span><br><span class="line">                <span class="attr">clientY</span>: <span class="number">96</span></span><br><span class="line">                <span class="attr">force</span>: <span class="number">1</span> <span class="comment">// 触摸压力</span></span><br><span class="line">                <span class="attr">identifier</span>: <span class="number">0</span> <span class="comment">// 唯一ID</span></span><br><span class="line">                <span class="attr">pageX</span>: <span class="number">232</span></span><br><span class="line">                <span class="attr">pageY</span>: <span class="number">96</span></span><br><span class="line">                <span class="attr">radiusX</span>: <span class="number">11.5</span></span><br><span class="line">                <span class="attr">radiusY</span>: <span class="number">11.5</span></span><br><span class="line">                <span class="attr">region</span>: <span class="literal">null</span></span><br><span class="line">                <span class="attr">rotationAngle</span>: <span class="number">0</span></span><br><span class="line">                <span class="attr">screenX</span>: <span class="number">476</span></span><br><span class="line">                <span class="attr">screenY</span>: <span class="number">266</span></span><br><span class="line">                <span class="attr">target</span>: html <span class="comment">// 触摸目标元素</span></span><br><span class="line">                <span class="attr">__proto__</span>: Touch</span><br><span class="line">                <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    	<span class="attr">__proto__</span>: TouchList</span><br><span class="line"></span><br><span class="line">    <span class="attr">composed</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">ctrlKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">currentTarget</span>: <span class="literal">null</span></span><br><span class="line">    <span class="attr">defaultPrevented</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">detail</span>: <span class="number">0</span></span><br><span class="line">    <span class="attr">eventPhase</span>: <span class="number">0</span></span><br><span class="line">    <span class="attr">isTrusted</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">metaKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">path</span>: (<span class="number">3</span>) [html, <span class="built_in">document</span>, Window]</span><br><span class="line">    <span class="attr">returnValue</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">shiftKey</span>: <span class="literal">false</span></span><br><span class="line">    <span class="attr">sourceCapabilities</span>: InputDeviceCapabilities &#123;<span class="attr">firesTouchEvents</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    <span class="attr">srcElement</span>: html</span><br><span class="line">    <span class="attr">target</span>: html</span><br><span class="line">    <span class="attr">targetTouches</span>: TouchList &#123;<span class="number">0</span>: Touch, <span class="attr">length</span>: <span class="number">1</span>&#125; <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">    <span class="attr">timeStamp</span>: <span class="number">994.1749999998137</span></span><br><span class="line">    <span class="attr">touches</span>: TouchList &#123;<span class="number">0</span>: Touch, <span class="attr">length</span>: <span class="number">1</span>&#125; <span class="comment">// TouchList 接口 （所有触摸点集合）</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;touchmove&quot;</span> <span class="comment">// 当前触摸事件类型</span></span><br><span class="line">    <span class="attr">view</span>: Window &#123;<span class="attr">postMessage</span>: ƒ, <span class="attr">blur</span>: ƒ, <span class="attr">focus</span>: ƒ, <span class="attr">close</span>: ƒ, <span class="attr">parent</span>: Window, …&#125;</span><br><span class="line">    <span class="attr">which</span>: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2、Touch-接口"><a href="#2、Touch-接口" class="headerlink" title="2、Touch 接口"></a>2、Touch 接口</h3><h4 id="2-1-Touch-接口概述-（单个触摸点）"><a href="#2-1-Touch-接口概述-（单个触摸点）" class="headerlink" title="2.1 Touch 接口概述 （单个触摸点）"></a>2.1 Touch 接口概述 （单个触摸点）</h4><p>Touch 接口<strong>代表单个触摸点</strong>。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure>

<p><code>Touch</code>构造函数接受一个<strong>配置对象作为参数</strong>，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<h4 id="2-2-Touch-接口的实例属性"><a href="#2-2-Touch-接口的实例属性" class="headerlink" title="2.2 Touch 接口的实例属性"></a>2.2 Touch 接口的实例属性</h4><h5 id="（1）Touch-identifier-触摸点的ID"><a href="#（1）Touch-identifier-触摸点的ID" class="headerlink" title="（1）Touch.identifier 触摸点的ID"></a>（1）Touch.identifier 触摸点的ID</h5><p><code>Touch.identifier</code>属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY-（相对屏幕、浏览器、文档的坐标）"><a href="#（2）Touch-screenX，Touch-screenY，Touch-clientX，Touch-clientY，pageX，pageY-（相对屏幕、浏览器、文档的坐标）" class="headerlink" title="（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）"></a>（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）</h5><p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</p>
<p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</p>
<h5 id="（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle-（触摸椭圆区域半径、角度）"><a href="#（3）Touch-radiusX，Touch-radiusY，Touch-rotationAngle-（触摸椭圆区域半径、角度）" class="headerlink" title="（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）"></a>（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）</h5><p><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性，分别返回<strong>触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度</strong>。</p>
<p><code>Touch.rotationAngle</code>属性表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</p>
<p>上面这三个属性共同定义了<strong>用户与屏幕接触的区域</strong>，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, rotate);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.changedTouches.item(<span class="number">0</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  src.style.width = touch.radiusX * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.height = touch.radiusY * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + touch.rotationAngle + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="（4）Touch-force-触摸压力"><a href="#（4）Touch-force-触摸压力" class="headerlink" title="（4）Touch.force 触摸压力"></a>（4）Touch.force 触摸压力</h5><p><code>Touch.force</code>属性返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</p>
<h5 id="（5）Touch-target-开始触摸时的元素"><a href="#（5）Touch-target-开始触摸时的元素" class="headerlink" title="（5）Touch.target 开始触摸时的元素"></a>（5）Touch.target 开始触摸时的元素</h5><p><code>Touch.target</code>属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</p>
<h3 id="3、TouchList-接口"><a href="#3、TouchList-接口" class="headerlink" title="3、TouchList 接口"></a>3、TouchList 接口</h3><p><code>TouchList</code>接口<strong>表示一组触摸点的集合</strong>。它的实例是一个<strong>类似数组的对象</strong>，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p>
<p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p>
<p>它的实例属性和实例方法只有两个。</p>
<ul>
<li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
<li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>
<h3 id="4、TouchEvent-接口"><a href="#4、TouchEvent-接口" class="headerlink" title="4、TouchEvent 接口"></a>4、TouchEvent 接口</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>TouchEvent 接口<strong>继承了 Event 接口</strong>，表示由<strong>触摸引发的事件实例</strong>，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。</p>
<p>浏览器原生提供<code>TouchEvent()</code>构造函数，用来生成触摸事件的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TouchEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p>
<ul>
<li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li>
</ul>
<h4 id="4-2-实例属性"><a href="#4-2-实例属性" class="headerlink" title="4.2 实例属性"></a>4.2 实例属性</h4><p>TouchEvent 接口的实例具有<code>Event</code>实例的所有属性和方法，此外还有一些它自己的实例属性，这些属性全部都是只读。</p>
<h5 id="（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey-（是否同时按某些功能键）"><a href="#（1）TouchEvent-altKey，TouchEvent-ctrlKey，TouchEvent-shiftKey，TouchEvent-metaKey-（是否同时按某些功能键）" class="headerlink" title="（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）"></a>（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）</h5><ul>
<li><code>TouchEvent.altKey</code>：布尔值，表示触摸时是否按下了 Alt 键。</li>
<li><code>TouchEvent.ctrlKey</code>：布尔值，表示触摸时是否按下了 Ctrl 键。</li>
<li><code>TouchEvent.shiftKey</code>：布尔值：表示触摸时是否按下了 Shift 键。</li>
<li><code>TouchEvent.metaKey</code>：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;altKey = &#x27;</span> + e.altKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ctrlKey = &#x27;</span> + e.ctrlKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;metaKey = &#x27;</span> + e.metaKey);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;shiftKey = &#x27;</span> + e.shiftKey);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（2）TouchEvent-changedTouches-（触摸点集合，不同触摸事件，含义不同）"><a href="#（2）TouchEvent-changedTouches-（触摸点集合，不同触摸事件，含义不同）" class="headerlink" title="（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）"></a>（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）</h5><p><code>TouchEvent.changedTouches</code>属性返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>
<p>对于<strong>不同的事件，该属性的含义有所不同。</strong></p>
<ul>
<li><code>touchstart</code>事件：被激活的触摸点</li>
<li><code>touchmove</code>事件：发生变化的触摸点</li>
<li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（3）TouchEvent-touches-（仍然活动的触摸点集合）"><a href="#（3）TouchEvent-touches-（仍然活动的触摸点集合）" class="headerlink" title="（3）TouchEvent.touches （仍然活动的触摸点集合）"></a>（3）TouchEvent.touches （仍然活动的触摸点集合）</h5><p><code>TouchEvent.touches</code>属性返回一个<code>TouchList</code>实例，成员是所有<strong>仍然处于活动状态（即触摸中）的触摸点</strong>。一般来说，一个手指就是一个触摸点。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (e.touches.length) &#123;</span><br><span class="line">    <span class="comment">// 一根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: handle_one_touch(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 两根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: handle_two_touches(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三根手指触摸</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: handle_three_touches(e); <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">console</span>.log(<span class="string">&#x27;Not supported&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h5 id="（4）TouchEvent-targetTouches-（目标元素内活动的触摸点集合）"><a href="#（4）TouchEvent-targetTouches-（目标元素内活动的触摸点集合）" class="headerlink" title="（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）"></a>（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）</h5><p><code>TouchEvent.targetTouches</code>属性返回一个<code>TouchList</code>实例，成员是<strong>触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touches_in_target</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (ev.touches.length === ev.targetTouches.length ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用来判断，是否所有触摸点都在目标元素内。</p>
<h3 id="5、触摸事件的种类"><a href="#5、触摸事件的种类" class="headerlink" title="5、触摸事件的种类"></a>5、触摸事件的种类</h3><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。<strong>【开始触摸】</strong></li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。<strong>【触摸结束】</strong></li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。<strong>【触摸移动中】</strong></li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。<strong>【触摸点被取消】</strong></li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;canvas&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, handleStart, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, handleMove, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStart</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(touches[i].pageX, touches[i].pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMove</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> touch = touches[i];</span><br><span class="line">    <span class="built_in">console</span>.log(touch.pageX, touch.pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、拖拉事件"><a href="#九、拖拉事件" class="headerlink" title="九、拖拉事件"></a>九、拖拉事件</h2><h3 id="1、拖拉事件的种类"><a href="#1、拖拉事件的种类" class="headerlink" title="1、拖拉事件的种类"></a>1、拖拉事件的种类</h3><p>拖拉（drag）指的是，<strong>用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里</strong>。</p>
<p>拖拉的对象有好几种，包括<strong>元素节点、图片、链接、选中的文字等等</strong>。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  此区域可拖拉</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>draggable</code>属性<strong>可用于任何元素节点</strong>，但是图片（<code> &lt;img&gt; </code>）和链接（<code> &lt;a&gt; </code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p>
<p><strong>注意</strong>，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，<strong>就无法再用鼠标选中该节点内部的文字或子节点</strong>了。</p>
<p>当元素节点或选中的文本被拖拉时，就<strong>会持续触发拖拉事件</strong>，包括以下一些事件。</p>
<p><strong>拖拉的节点上触发：</strong></p>
<ul>
<li><code>drag</code>：<strong>拖拉过程中</strong>，在被拖拉的节点上<strong>持续触发</strong>（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户<strong>开始拖拉时</strong>，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：<strong>拖拉结束时</strong>（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
</ul>
<p><strong>拖拉到别的节点上触发：</strong></p>
<ul>
<li><p><code>dragenter</code>：<strong>拖拉进入当前节点</strong>时，<strong>在当前节点上触发一次</strong>，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，<strong>指定是否允许在当前节点放下（drop）拖拉的数据</strong>。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</p>
</li>
<li><p><code>dragover</code>：<strong>拖拉到当前节点上方时</strong>，在当前节点上<strong>持续触发</strong>（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</p>
</li>
<li><p><code>dragleave</code>：<strong>拖拉操作离开当前节点范围时</strong>，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</p>
</li>
<li><p><code>drop</code>：被拖拉的节点或选中的文本，<strong>释放到目标节点时，在目标节点上触发</strong>。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</p>
</li>
</ul>
<p>下面的例子展示，如何动态改变被拖动节点的背景色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    div1，此区域可拖拉</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span></span><br><span class="line">    div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.div1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.div2&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    div1.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;开始拖拉&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    div1.addEventListener(<span class="string">&#x27;drag&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;拖拉中&#x27;</span>) <span class="comment">// 持续触发</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    div1.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;结束拖拉&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    div2.addEventListener(<span class="string">&#x27;dragenter&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;拖到了div2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    div2.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//console.log(&#x27;正在div2上方&#x27;) // 持续触发</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    div2.addEventListener(<span class="string">&#x27;dragleave&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;离开div2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    div2.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;在div2上释放&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;</span></span><br><span class="line"><span class="comment">   &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">     该节点可拖拉</span></span><br><span class="line"><span class="comment">   &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被拖拉节点</span></span><br><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存被拖拉节点</span></span><br><span class="line">  dragged = event.target;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色变透明</span></span><br><span class="line">  event.target.style.opacity = <span class="number">0.5</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色恢复正常</span></span><br><span class="line">  event.target.style.opacity = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色变紫色</span></span><br><span class="line">  <span class="comment">// 由于该事件会冒泡，所以要过滤节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragleave&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色恢复原样</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 恢复目标节点背景色</span></span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 将被拖拉节点插入目标节点</span></span><br><span class="line">    dragged.parentNode.removeChild(dragged);</span><br><span class="line">    event.target.appendChild( dragged );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>关于拖拉事件，有以下几个注意点。</p>
<ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是<strong>鼠标事件不会触发</strong>。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。<strong>如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为</strong>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。</p>
<h3 id="2、DragEvent-接口"><a href="#2、DragEvent-接口" class="headerlink" title="2、DragEvent 接口"></a>2、DragEvent 接口</h3><p><strong>拖拉事件都继承了<code>DragEvent</code>接口，这个接口又继承了<code>MouseEvent</code>接口和<code>Event</code>接口。</strong></p>
<p>浏览器原生提供一个<code>DragEvent()</code>构造函数，用来生成拖拉事件的实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DragEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是<strong>字符串，表示事件的类型</strong>，该参数必须；第二个参数是事件的<strong>配置对象</strong>，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以<strong>设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</strong></p>
<p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>
<h3 id="3、DataTransfer-接口概述"><a href="#3、DataTransfer-接口概述" class="headerlink" title="3、DataTransfer 接口概述"></a>3、DataTransfer 接口概述</h3><p><strong>所有拖拉事件的实例都有一个<code>DragEvent.dataTransfer</code>属性，用来读写需要传递的数据</strong>。这个属性的值是一个<code>DataTransfer</code>接口的实例。</p>
<p>浏览器原生提供一个<code>DataTransfer()</code>构造函数，用来生成<code>DataTransfer</code>实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataTrans = <span class="keyword">new</span> DataTransfer();</span><br></pre></td></tr></table></figure>

<p><code>DataTransfer()</code>构造函数<strong>不接受参数</strong>。</p>
<p>拖拉的数据分成两方面：<strong>数据的种类（又称格式）和数据的值</strong>。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>
<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p>
<p><strong>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</strong></p>
<h3 id="4、DataTransfer-的实例属性"><a href="#4、DataTransfer-的实例属性" class="headerlink" title="4、DataTransfer 的实例属性"></a>4、DataTransfer 的实例属性</h3><h4 id="4-1-DataTransfer-dropEffect-设置接受拖拉的区域的效果"><a href="#4-1-DataTransfer-dropEffect-设置接受拖拉的区域的效果" class="headerlink" title="4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果"></a>4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果</h4><p><code>DataTransfer.dropEffect</code>属性<strong>用来设置放下（drop）被拖拉节点时的效果</strong>，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉的节点的链接</li>
<li>none：无法放下被拖拉的节点</li>
</ul>
<p>除了上面这些值，设置其他的值都是无效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  e.dataTransfer.dropEffect = <span class="string">&#x27;copy&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，被拖拉元素一旦<code>drop</code>，接受的区域会复制该节点。</p>
<p><code>dropEffect</code>属性一般<strong>在<code>dragenter</code>和<code>dragover</code>事件的监听函数中设置</strong>，对于<code>dragstart</code>、<code>drag</code>、<code>dragleave</code>这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果。</p>
<h4 id="4-2-DataTransfer-effectAllowed-设置被拖拉的节点允许的效果"><a href="#4-2-DataTransfer-effectAllowed-设置被拖拉的节点允许的效果" class="headerlink" title="4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果"></a>4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果</h4><p><code>DataTransfer.effectAllowed</code>属性<strong>设置本次拖拉中允许的效果</strong>。它可能取下面的值。</p>
<ul>
<li>copy：复制被拖拉的节点</li>
<li>move：移动被拖拉的节点</li>
<li>link：创建指向被拖拉节点的链接</li>
<li>copyLink：允许<code>copy</code>或<code>link</code></li>
<li>copyMove：允许<code>copy</code>或<code>move</code></li>
<li>linkMove：允许<code>link</code>或<code>move</code></li>
<li>all：允许所有效果</li>
<li>none：无法放下被拖拉的节点</li>
<li>uninitialized：默认值，等同于<code>all</code></li>
</ul>
<p>如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。</p>
<p><strong>这个属性与<code>dropEffect</code>属性是同一件事的两个方面。前者设置被拖拉的节点允许的效果，后者设置接受拖拉的区域的效果，它们往往配合使用。</strong></p>
<p><strong><code>dragstart</code>事件的监听函数，可以用来设置这个属性</strong>。其他事件的监听函数里面设置这个属性是无效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 被拖拉节点上设置</span></span><br><span class="line">  e.dataTransfer.effectAllowed = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 接受区域节点上设置</span></span><br><span class="line">  e.dataTransfer.dropEffect = <span class="string">&#x27;move&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只要<code>dropEffect</code>属性和<code>effectAllowed</code>属性之中，有一个为<code>none</code>，就无法在目标节点上完成<code>drop</code>操作。</p>
<h4 id="4-3-DataTransfer-files-本地文件"><a href="#4-3-DataTransfer-files-本地文件" class="headerlink" title="4.3 DataTransfer.files 本地文件"></a>4.3 DataTransfer.files 本地文件</h4><p><code>DataTransfer.files</code>属性是<strong>一个 FileList 对象，包含一组本地文件</strong>，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</p>
<h5 id="例子：接收拖拉文件"><a href="#例子：接收拖拉文件" class="headerlink" title="例子：接收拖拉文件"></a>例子：接收拖拉文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;output&quot; style=&quot;min-height: 200px;border: 1px solid black;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   文件拖拉到这里</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;dragenter&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  div.textContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;dragover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&quot;drop&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> files = event.dataTransfer.files;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    div.textContent += files[i].name + <span class="string">&#x27; &#x27;</span> + files[i].size + <span class="string">&#x27;字节\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过<code>dataTransfer.files</code>属性读取被拖拉的文件的信息。如果想要<strong>读取文件内容，就要使用<code>FileReader</code>对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  e.stopPropagation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fileList = e.dataTransfer.files;</span><br><span class="line">  <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.readAsDataURL(file);<span class="comment">// 解析为url</span></span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (e.target.readyState === FileReader.DONE) &#123;</span><br><span class="line">        <span class="keyword">var</span> content = reader.result;</span><br><span class="line">        div.innerHTML = <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>+ content +<span class="string">&#x27;&quot;&gt; File: &#x27;</span> + file.name + <span class="string">&#x27;\n\n&#x27;</span> + content;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsBinaryString(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="4-4-DataTransfer-types-数据格式"><a href="#4-4-DataTransfer-types-数据格式" class="headerlink" title="4.4 DataTransfer.types 数据格式"></a>4.4 DataTransfer.types 数据格式</h4><p><code>DataTransfer.types</code>属性<strong>是一个只读的数组</strong>，每个成员是一个字符串，里面是<strong>拖拉的数据格式</strong>（通常是 MIME 值）。比如，如果拖拉的是文字，对应的成员就是<code>text/plain</code>。</p>
<p>下面是一个例子，通过检查<code>dataTransfer</code>属性的类型，决定是否允许在当前节点执行<code>drop</code>操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">list, value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i] === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDragOver</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLink = contains(event.dataTransfer.types, <span class="string">&#x27;text/uri-list&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (isLink) event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。</p>
<h4 id="4-5-DataTransfer-items"><a href="#4-5-DataTransfer-items" class="headerlink" title="4.5 DataTransfer.items"></a>4.5 DataTransfer.items</h4><p><code>DataTransfer.items</code>属性<strong>返回一个类似数组的只读对象（DataTransferItemList 实例）</strong>，每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</p>
<p>DataTransferItemList 实例具有以下的属性和方法。</p>
<ul>
<li><code>length</code>：返回成员的数量</li>
<li><code>add(data, type)</code>：增加一个指定内容和类型（比如<code>text/html</code>和<code>text/plain</code>）的字符串作为成员</li>
<li><code>add(file)</code>：<code>add</code>方法的另一种用法，增加一个文件作为成员</li>
<li><code>remove(index)</code>：移除指定位置的成员</li>
<li><code>clear()</code>：移除所有的成员</li>
</ul>
<p>DataTransferItem 实例具有以下的属性和方法。</p>
<ul>
<li><code>kind</code>：返回成员的种类（<code>string</code>还是<code>file</code>）。</li>
<li><code>type</code>：返回成员的类型（通常是 MIME 值）。</li>
<li><code>getAsFile()</code>：如果被拖拉是文件，返回该文件，否则返回<code>null</code>。</li>
<li><code>getAsString(callback)</code>：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (e.dataTransfer.items != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.dataTransfer.items.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.dataTransfer.items[i].kind + <span class="string">&#x27;: &#x27;</span> + e.dataTransfer.items[i].type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="5、DataTransfer-的实例方法"><a href="#5、DataTransfer-的实例方法" class="headerlink" title="5、DataTransfer 的实例方法"></a>5、DataTransfer 的实例方法</h3><h4 id="5-1-DataTransfer-setData-设置拖拉事件所带有的数据"><a href="#5-1-DataTransfer-setData-设置拖拉事件所带有的数据" class="headerlink" title="5.1 DataTransfer.setData() 设置拖拉事件所带有的数据"></a>5.1 DataTransfer.setData() 设置拖拉事件所带有的数据</h4><p><code>DataTransfer.setData()</code>方法用来<strong>设置拖拉事件所带有的数据</strong>。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Text to drag&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码为当前的拖拉事件加入纯文本数据。</p>
<p>该方法接受两个参数，都是字符串。第一个参数<strong>表示数据类型</strong>（比如<code>text/plain</code>），第二个参数是<strong>具体数据</strong>。如果指定类型的数据在<code>dataTransfer</code>属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。</p>
<p>如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到<code>dataTransfer</code>属性，不用手动指定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  aaa</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉这个<code> &lt;div&gt; </code>元素会自动带上文本数据<code>aaa</code>。</p>
<p>使用<code>setData</code>方法，可以替换到原有数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragstart</span>=<span class="string">&quot;event.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;bbb&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  aaa</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拖拉数据实际上是<code>bbb</code>，而不是<code>aaa</code>。</p>
<p>下面是添加其他类型的数据。由于<code>text/plain</code>是最普遍支持的格式，为了保证兼容性，建议最后总是保存一份纯文本格式的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加链接</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 HTML 代码</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello there, &lt;strong&gt;stranger&lt;/strong&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加图像的 URL</span></span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, imageurl);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, imageurl);</span><br></pre></td></tr></table></figure>

<p>可以一次提供多种格式的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dt = event.dataTransfer;</span><br><span class="line">dt.setData(<span class="string">&#x27;application/x-bookmark&#x27;</span>, bookmarkString);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br><span class="line">dt.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，<code>drop</code>不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能<code>drop</code>（读取到）这个数据。</p>
<h4 id="5-2-DataTransfer-getData-返回指定类型的数据"><a href="#5-2-DataTransfer-getData-返回指定类型的数据" class="headerlink" title="5.2 DataTransfer.getData() 返回指定类型的数据"></a>5.2 DataTransfer.getData() 返回指定类型的数据</h4><p><code>DataTransfer.getData()</code>方法接受一个字符串（表示数据类型）作为参数，<strong>返回事件所带的指定类型的数据（通常是用<code>setData</code>方法添加的数据）</strong>。如果指定类型的数据不存在，则返回空字符串。通常只有<code>drop</code>事件触发后，才能取出数据。</p>
<p>下面是一个<code>drop</code>事件的监听函数，用来取出指定类型的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.dataTransfer.getData(<span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">  event.target.textContent = data;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。</p>
<p><code>getData</code>方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lines = event.dataTransfer.getData(<span class="string">&#x27;text/uri-list&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    <span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    link.href = line;</span><br><span class="line">    link.textContent = line;</span><br><span class="line">    event.target.appendChild(link);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getData</code>方法返回的是一组链接，就必须自行解析。</p>
<p>类型值指定为<code>URL</code>，可以取出第一个有效链接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = event.dataTransfer.getData(<span class="string">&#x27;URL&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面的例子是从多种类型的数据里面取出数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> types = event.dataTransfer.types;</span><br><span class="line">  <span class="keyword">var</span> supportedTypes = [<span class="string">&#x27;text/uri-list&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>];</span><br><span class="line">  types = supportedTypes.filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; types.includes(value) &#125;);</span><br><span class="line">  <span class="keyword">if</span> (types.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.dataTransfer.getData(types[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-3-DataTransfer-clearData-清除指定或全部数据"><a href="#5-3-DataTransfer-clearData-清除指定或全部数据" class="headerlink" title="5.3 DataTransfer.clearData() 清除指定或全部数据"></a>5.3 DataTransfer.clearData() 清除指定或全部数据</h4><p><code>DataTransfer.clearData()</code>方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.dataTransfer.clearData(<span class="string">&#x27;text/uri-list&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码清除事件所带的<code>text/uri-list</code>类型的数据。</p>
<p>该方法不会移除拖拉的文件，因此调用该方法后，<code>DataTransfer.types</code>属性可能依然会返回<code>Files</code>类型（前提是存在文件拖拉）。</p>
<p>注意，该方法<strong>只能在<code>dragstart</code>事件的监听函数之中使用</strong>，因为这是拖拉操作的数据唯一可写的时机。</p>
<h4 id="5-4-DataTransfer-setDragImage-设置拖动过程中的图片"><a href="#5-4-DataTransfer-setDragImage-设置拖动过程中的图片" class="headerlink" title="5.4 DataTransfer.setDragImage() 设置拖动过程中的图片"></a>5.4 DataTransfer.setDragImage() 设置拖动过程中的图片</h4><p>拖动过程中（<code>dragstart</code>事件触发后），浏览器<strong>会显示一张图片跟随鼠标一起移动</strong>，表示被拖动的节点。这张图片是<strong>自动创造的</strong>，通常显示为被拖动节点的外观，不需要自己动手设置。</p>
<p><code>DataTransfer.setDragImage()</code>方法<strong>可以自定义这张图片</strong>。它接受三个参数。第一个是<code> &lt;img&gt; </code>节点或者<code>&lt;canvas&gt;</code>节点，如果省略或为<code>null</code>，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div id=&quot;drag-with-image&quot; class=&quot;dragdemo&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">   drag me</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;drag-with-image&#x27;</span>);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  img.src = <span class="string">&#x27;http://path/to/img&#x27;</span>;</span><br><span class="line">  e.dataTransfer.setDragImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h2 id="十、其他常见事件"><a href="#十、其他常见事件" class="headerlink" title="十、其他常见事件"></a>十、其他常见事件</h2><h3 id="1、资源事件"><a href="#1、资源事件" class="headerlink" title="1、资源事件"></a>1、资源事件</h3><h4 id="1-1-beforeunload-事件-（关闭窗口前调用）"><a href="#1-1-beforeunload-事件-（关闭窗口前调用）" class="headerlink" title="1.1 beforeunload 事件 （关闭窗口前调用）"></a>1.1 beforeunload 事件 （关闭窗口前调用）</h4><p><code>beforeunload</code>事件在<strong>窗口、文档、各种资源将要卸载前触发</strong>。它可以用来防止用户不小心卸载资源。</p>
<p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="string">&#x27;你确定离开吗？&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户如果<strong>关闭窗口，浏览器会弹出一个窗口，要求用户确认</strong>。</p>
<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，<strong>大多数浏览器在对话框中不显示指定文本，只显示默认文本</strong>。因此，可以采用下面的写法，取得最大的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">&#x27;确认关闭窗口？&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  e.returnValue = confirmationMessage;</span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，许多手机浏览器默认忽略这个事件，桌面浏览器也有办法忽略这个事件。所以，它可能根本不会生效，不能依赖它来阻止用户关闭窗口。另外，一旦使用了<code>beforeunload</code>事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。这是因为监听这个事件的目的，一般是修改初始状态，这时缓存初始页面就没意义了。</p>
<p>基本上，只有一种场合可以监听<code>unload</code>事件，其他情况都不应该监听：<strong>用户修改了表单，还没有保存就要离开</strong>。</p>
<h4 id="1-2-unload-事件-（即将关闭窗口时调用）"><a href="#1-2-unload-事件-（即将关闭窗口时调用）" class="headerlink" title="1.2 unload 事件 （即将关闭窗口时调用）"></a>1.2 unload 事件 （即将关闭窗口时调用）</h4><p><code>unload</code>事件在<strong>窗口关闭或者<code>document</code>对象将要卸载时触发</strong>。它的触发顺序排在<code>beforeunload</code>、<code>pagehide</code>事件后面。</p>
<p><code>unload</code>事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;文档将要卸载&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code>beforeunload</code>事件一样，一旦使用了<code>unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<h4 id="1-3-load-事件，error-事件-，abort事件-（页面或某个资源加载成功-失败-取消时调用）"><a href="#1-3-load-事件，error-事件-，abort事件-（页面或某个资源加载成功-失败-取消时调用）" class="headerlink" title="1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功/失败/取消时调用）"></a>1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功/失败/取消时调用）</h4><p><code>load</code>事件<strong>在页面或某个资源加载成功时触发</strong>。注意，<strong>页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;所有资源都加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>error</code>事件是<strong>在页面或资源加载失败时触发</strong>。</p>
<p><code>abort</code>事件是<strong>在用户取消加载时触发</strong>。</p>
<p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p>
<p><strong>触发这三个事件的对象有</strong>：</p>
<ul>
<li>window</li>
<li>document</li>
<li>body</li>
<li>img</li>
<li>style</li>
<li>script</li>
<li>video</li>
<li>audio</li>
<li>Ajax</li>
<li>等等</li>
</ul>
<h3 id="2、session-历史事件"><a href="#2、session-历史事件" class="headerlink" title="2、session 历史事件"></a>2、session 历史事件</h3><h4 id="2-1-pageshow-事件（页面显示，加载页面后执行），pagehide-事件（退出当前页面触发）"><a href="#2-1-pageshow-事件（页面显示，加载页面后执行），pagehide-事件（退出当前页面触发）" class="headerlink" title="2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）"></a>2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）</h4><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户<strong>点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</strong></p>
<p>pageshow 事件<strong>在页面加载时触发，包括第一次加载和从缓存加载两种情况</strong>。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p>
<p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;pageshow: &#x27;</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>pageshow 事件<strong>有一个<code>persisted</code>属性</strong>，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.persisted) &#123; <span class="comment">// 是否从缓存加载</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户<strong>通过“前进/后退”按钮，离开当前页面时触发</strong>。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p>
<p><code>pagehide</code>事件实例也<strong>有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中</strong>，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>
<p>如果页面包含<code>&lt;frame&gt;</code>或<code> &lt;iframe&gt; </code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p>
<p><strong>注意，这两个事件只在浏览器的<code>history</code>（历史）对象发生变化时触发，跟网页是否可见没有关系。</strong></p>
<h4 id="2-2-popstate-事件（在浏览器的history对象的当前记录发生显式切换时触发）"><a href="#2-2-popstate-事件（在浏览器的history对象的当前记录发生显式切换时触发）" class="headerlink" title="2.2 popstate 事件（在浏览器的history对象的当前记录发生显式切换时触发）"></a>2.2 popstate 事件（在浏览器的<code>history</code>对象的当前记录发生显式切换时触发）</h4><p><code>popstate</code>事件<strong>在浏览器的<code>history</code>对象的当前记录发生显式切换时触发</strong>。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如<strong>鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发</strong>。</p>
<p>该事件对象有一个<code>state</code>属性，保存<code>history.pushState</code>方法和<code>history.replaceState</code>方法为当前记录添加的<code>state</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;state: &#x27;</span> + event.state);</span><br><span class="line">&#125;;</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;title 1&#x27;</span>, <span class="string">&#x27;?page=1&#x27;</span>);</span><br><span class="line">history.pushState(&#123;<span class="attr">page</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;title 2&#x27;</span>, <span class="string">&#x27;?page=2&#x27;</span>);</span><br><span class="line">history.replaceState(&#123;<span class="attr">page</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;title 3&#x27;</span>, <span class="string">&#x27;?page=3&#x27;</span>);</span><br><span class="line">history.back(); <span class="comment">// state: &#123;&quot;page&quot;:1&#125;</span></span><br><span class="line">history.back(); <span class="comment">// state: null</span></span><br><span class="line">history.go(<span class="number">2</span>);  <span class="comment">// state: &#123;&quot;page&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>pushState</code>方法向<code>history</code>添加了两条记录，然后<code>replaceState</code>方法替换掉当前记录。因此，连续两次<code>back</code>方法，会让当前条目退回到原始网址，它没有附带<code>state</code>对象，所以事件的<code>state</code>属性为<code>null</code>，然后前进两条记录，又回到<code>replaceState</code>方法添加的记录。</p>
<p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>
<h4 id="2-3-hashchange-事件-（hash发生变化时触发）"><a href="#2-3-hashchange-事件-（hash发生变化时触发）" class="headerlink" title="2.3 hashchange 事件 （hash发生变化时触发）"></a>2.3 hashchange 事件 （hash发生变化时触发）</h4><p><code>hashchange</code>事件在 U<strong>RL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发</strong>。该事件<strong>一般在<code>window</code>对象上监听</strong>。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 是 http://www.example.com/</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.oldURL);</span><br><span class="line">  <span class="built_in">console</span>.log(e.newURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.hash = <span class="string">&#x27;part2&#x27;</span>;</span><br><span class="line"><span class="comment">// http://www.example.com/</span></span><br><span class="line"><span class="comment">// http://www.example.com/#part2</span></span><br></pre></td></tr></table></figure>



<h3 id="3、网页状态事件"><a href="#3、网页状态事件" class="headerlink" title="3、网页状态事件"></a>3、网页状态事件</h3><h4 id="3-1-DOMContentLoaded-事件-（DOM内容加载完成后触发）"><a href="#3-1-DOMContentLoaded-事件-（DOM内容加载完成后触发）" class="headerlink" title="3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）"></a>3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）</h4><p><strong>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件</strong>。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），<strong>所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束</strong>。也就是说，这个事件<strong>比<code>load</code>事件，发生时间早得多</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，网页的 JavaScript 脚本是同步执行的，脚本一旦发生堵塞，将推迟触发<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DOM 生成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会推迟触发 DOMContentLoaded 事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-readystatechange-事件（Document-对象和-XMLHttpRequest-对象的readyState属性发生变化时触发）"><a href="#3-2-readystatechange-事件（Document-对象和-XMLHttpRequest-对象的readyState属性发生变化时触发）" class="headerlink" title="3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发）"></a>3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发）</h4><p><code>readystatechange</code>事件<strong>当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发</strong>。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&#x27;interactive&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p>
<h3 id="4、窗口事件"><a href="#4、窗口事件" class="headerlink" title="4、窗口事件"></a>4、窗口事件</h3><h4 id="4-1-scroll-事件-（文档或文档元素滚动时触发）"><a href="#4-1-scroll-事件-（文档或文档元素滚动时触发）" class="headerlink" title="4.1 scroll 事件 （文档或文档元素滚动时触发）"></a>4.1 scroll 事件 （文档或文档元素滚动时触发）</h4><p><code>scroll</code>事件在<strong>文档或文档元素滚动时触发</strong>，主要出现在用户拖动滚动条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>

<p>该事件<strong>会连续地大量触发</strong>，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">type, name, obj</span>) </span>&#123; <span class="comment">// 节流函数 控制触发频率</span></span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 结合此方法控制在每秒60次</span></span><br><span class="line">        obj.dispatchEvent(<span class="keyword">new</span> CustomEvent(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件重定义为 optimizedScroll 事件</span></span><br><span class="line">  throttle(<span class="string">&#x27;scroll&#x27;</span>, <span class="string">&#x27;optimizedScroll&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;optimizedScroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Resource conscious scroll callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throttle</code>函数用于控制事件触发频率，<code>requestAnimationFrame</code>方法保证每次页面重绘（每秒60次），只会触发一次<code>scroll</code>事件的监听函数。也就是说，上面方法将<code>scroll</code>事件的触发频率，限制在每秒60次。具体来说，就是<code>scroll</code>事件只要频率低于每秒60次，就会触发<code>optimizedScroll</code>事件，从而执行<code>optimizedScroll</code>事件的监听函数。</p>
<p>改用<code>setTimeout</code>方法，可以放置更大的时间间隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollThrottler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">actualScrollHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p>
<p>下面是一个更一般的<code>throttle</code>函数的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="built_in">Date</span>.now()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p>
<p><a target="_blank" rel="noopener" href="https://www.lodashjs.com/">lodash</a>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, _.throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>本书前面介绍过<code>debounce</code>的概念，<code>throttle</code>与它区别在于，<code>throttle</code>是“节流”，确保一段时间内只执行一次，而<code>debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code>debounce</code>要等到用户停止滚动后才执行，<code>throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>
<h4 id="4-2-resize-事件（窗口大小变化时触发）"><a href="#4-2-resize-事件（窗口大小变化时触发）" class="headerlink" title="4.2 resize 事件（窗口大小变化时触发）"></a>4.2 resize 事件（窗口大小变化时触发）</h4><p><code>resize</code>事件<strong>在改变浏览器窗口大小时触发</strong>，主要<strong>发生在<code>window</code>对象上面</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
<h4 id="4-3-fullscreenchange-事件（元素进入-退出全屏时触发），fullscreenerror-事件（无法切换全屏时触发）"><a href="#4-3-fullscreenchange-事件（元素进入-退出全屏时触发），fullscreenerror-事件（无法切换全屏时触发）" class="headerlink" title="4.3 fullscreenchange 事件（元素进入/退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）"></a>4.3 fullscreenchange 事件（元素进入/退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）</h4><p><code>fullscreenchange</code>事件<strong>在元素进入或退出全屏状态时触发</strong>，该事件<strong>发生在<code>document</code>对象上面</strong>。</p>
<p><strong>注意，此事件非浏览器的进入/退出全屏时触发的事件。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement); <span class="comment">// 全屏的元素，如果为null时表示已退出全屏</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>).requestFullscreen(); <span class="comment">// 设置元素为全屏展示</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fullscreenerror</code>事件在<strong>浏览器无法切换到全屏状态时触发</strong>。</p>
<h3 id="5、剪贴板事件"><a href="#5、剪贴板事件" class="headerlink" title="5、剪贴板事件"></a>5、剪贴板事件</h3><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。<strong>【剪切】</strong></li>
<li><code>copy</code>：进行复制动作时触发。<strong>【拷贝】</strong></li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。<strong>【粘贴】</strong></li>
</ul>
<p>这三个事件都是**<code>ClipboardEvent</code>接口的实例**。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<h3 id="6、焦点事件"><a href="#6、焦点事件" class="headerlink" title="6、焦点事件"></a>6、焦点事件</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点<strong>获得焦点</strong>后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点<strong>失去焦点</strong>后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点<strong>将要获得焦点</strong>时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点<strong>将要失去焦点</strong>时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<p>这四个事件都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p>
<ul>
<li><code>FocusEvent.target</code>：事件的目标节点。</li>
<li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li>
</ul>
<p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">form.addEventListener(<span class="string">&#x27;blur&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>
<h3 id="7、CustomEvent-接口（自定义事件）"><a href="#7、CustomEvent-接口（自定义事件）" class="headerlink" title="7、CustomEvent 接口（自定义事件）"></a>7、CustomEvent 接口（自定义事件）</h3><p>CustomEvent 接口<strong>用于生成自定义的事件实例</strong>。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;myevent&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">detail</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;myevent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
<h2 id="十一、GlobalEventHandlers-接口-（全局事件处理接口）"><a href="#十一、GlobalEventHandlers-接口-（全局事件处理接口）" class="headerlink" title="十一、GlobalEventHandlers 接口 （全局事件处理接口）"></a>十一、GlobalEventHandlers 接口 （全局事件处理接口）</h2><p>指定事件的回调函数，推荐使用的方法是元素的<code>addEventListener</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.onclick = clickHandler;</span><br></pre></td></tr></table></figure>

<p>这个接口是由<code>GlobalEventHandlers</code>接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>
<p><strong><code>HTMLElement</code>、<code>Document</code>和<code>Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code>document</code>对象、<code>window</code>对象上面都可以使用<code>GlobalEventHandlers</code>接口提供的属性</strong>。下面就列出这个接口提供的主要的事件属性。</p>
<h3 id="1、GlobalEventHandlers-onabort-（中断事件）"><a href="#1、GlobalEventHandlers-onabort-（中断事件）" class="headerlink" title="1、GlobalEventHandlers.onabort （中断事件）"></a>1、GlobalEventHandlers.onabort （中断事件）</h3><p>某个对象的<code>abort</code>事件（停止加载）发生时，就会调用<code>onabort</code>属性指定的回调函数。</p>
<p>各种元素的停止加载事件，到底如何触发，目前并没有统一的规定。因此实际上，这个属性现在一般只用在<code>&lt;img&gt;</code>元素上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;example.jpg&quot; id=&quot;img&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;图片加载中断&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、GlobalEventHandlers-onerror-（错误事件）"><a href="#2、GlobalEventHandlers-onerror-（错误事件）" class="headerlink" title="2、GlobalEventHandlers.onerror （错误事件）"></a>2、GlobalEventHandlers.onerror （错误事件）</h3><p><code>error</code>事件发生时，就会调用<code>onerror</code>属性指定的回调函数。</p>
<p><code>error</code>事件<strong>分成两种</strong>。</p>
<p><strong>一种是 JavaScript 的运行时错误</strong>，这会传到<code>window</code>对象，导致<code>window.onerror()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.onerror</code>的处理函数共接受五个参数，含义如下。</p>
<ul>
<li>message：错误信息字符串</li>
<li>source：报错脚本的 URL</li>
<li>lineno：报错的行号，是一个整数</li>
<li>colno：报错的列号，是一个整数</li>
<li>error： 错误对象</li>
</ul>
<p>另<strong>一种是资源加载错误</strong>，比如<code> &lt;img&gt; </code>或<code> &lt;script&gt; </code>加载的资源出现加载错误。这时，Error 对象会传到对应的元素，导致该元素的<code>onerror</code>属性开始执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，一般来说，资源的加载错误不会触发<code>window.onerror</code>。</p>
<h3 id="3、GlobalEventHandlers-onload（加载完成事件）、GlobalEventHandlers-onloadstart（开始加载事件）"><a href="#3、GlobalEventHandlers-onload（加载完成事件）、GlobalEventHandlers-onloadstart（开始加载事件）" class="headerlink" title="3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）"></a>3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）</h3><p>元素完成加载时，会触发<code>load</code>事件，执行<code>onload()</code>。它的典型使用场景是<code>window</code>对象和<code> &lt;img&gt; </code>元素。对于<code>window</code>对象来说，只有页面的所有资源加载完成（包括图片、脚本、样式表、字体等所有外部资源），才会触发<code>load</code>事件。</p>
<p>对于<code> &lt;img&gt; </code>和<code> &lt;video&gt; </code>等元素，加载开始时还会触发<code>loadstart</code>事件，导致执行<code>onloadstart</code>。</p>
<h3 id="4、GlobalEventHandlers-onfocus（获取焦点事件），GlobalEventHandlers-onblur（失去焦点事件）"><a href="#4、GlobalEventHandlers-onfocus（获取焦点事件），GlobalEventHandlers-onblur（失去焦点事件）" class="headerlink" title="4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）"></a>4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）</h3><p>当前元素获得焦点时，会触发<code>element.onfocus</code>；失去焦点时，会触发<code>element.onblur</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">element.onfocus = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onfocus event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">element.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onblur event detected!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，如果不是可以接受用户输入的元素，要触发<code>onfocus</code>，该元素必须有<code>tabindex</code>属性。</p>
<h3 id="5、GlobalEventHandlers-onscroll（滚动事件）"><a href="#5、GlobalEventHandlers-onscroll（滚动事件）" class="headerlink" title="5、GlobalEventHandlers.onscroll（滚动事件）"></a>5、GlobalEventHandlers.onscroll（滚动事件）</h3><p>页面或元素滚动时，会触发<code>scroll</code>事件，导致执行<code>onscroll()</code>。</p>
<h3 id="6、GlobalEventHandlers-oncontextmenu（右键菜单事件），GlobalEventHandlers-onshow（显示右键菜单时触发）"><a href="#6、GlobalEventHandlers-oncontextmenu（右键菜单事件），GlobalEventHandlers-onshow（显示右键菜单时触发）" class="headerlink" title="6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）"></a>6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）</h3><p>用户在页面上按下鼠标的右键，会触发<code>contextmenu</code>事件，导致执行<code>oncontextmenu()</code>。如果该属性执行后返回<code>false</code>，就等于禁止了右键菜单。<code>document.oncontextmenu</code>与<code>window.oncontextmenu</code>效果一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// 禁用右键菜单</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>oncontextmenu</code>属性执行后返回<code>false</code>，右键菜单就不会出现。</p>
<p>元素的右键菜单显示时，会触发该元素的<code>onshow</code>监听函数。</p>
<h3 id="7、其他的事件属性"><a href="#7、其他的事件属性" class="headerlink" title="7、其他的事件属性"></a>7、其他的事件属性</h3><p>鼠标的事件属性。</p>
<ul>
<li>onclick</li>
<li>ondblclick</li>
<li>onmousedown</li>
<li>onmouseenter</li>
<li>onmouseleave</li>
<li>onmousemove</li>
<li>onmouseout</li>
<li>onmouseover</li>
<li>onmouseup</li>
<li>onwheel</li>
</ul>
<p>键盘的事件属性。</p>
<ul>
<li>onkeydown</li>
<li>onkeypress</li>
<li>onkeyup</li>
</ul>
<p>焦点的事件属性。</p>
<ul>
<li>onblur</li>
<li>onfocus</li>
</ul>
<p>表单的事件属性。</p>
<ul>
<li>oninput</li>
<li>onchange</li>
<li>onsubmit</li>
<li>onreset</li>
<li>oninvalid</li>
<li>onselect</li>
</ul>
<p>触摸的事件属性。</p>
<ul>
<li>ontouchcancel</li>
<li>ontouchend</li>
<li>ontouchmove</li>
<li>ontouchstart</li>
</ul>
<p>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</p>
<p>被拖动元素的事件属性。</p>
<ul>
<li>ondragstart：拖动开始</li>
<li>ondrag：拖动过程中，每隔几百毫秒触发一次</li>
<li>ondragend：拖动结束</li>
</ul>
<p>接收被拖动元素的容器元素的事件属性。</p>
<ul>
<li>ondragenter：被拖动元素进入容器元素。</li>
<li>ondragleave：被拖动元素离开容器元素。</li>
<li>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</li>
<li>ondrop：松开鼠标后，被拖动元素放入容器元素。</li>
</ul>
<p><code>&lt;dialog&gt;</code>对话框元素的事件属性。</p>
<ul>
<li>oncancel</li>
<li>onclose</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学习文档：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/">https://wangdoc.com/javascript/</a></p>
<blockquote>
<p>文章来源<a target="_blank" rel="noopener" href="https://github.com/xugaoyi">https://github.com/xugaoyi</a></p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS%E5%9F%BA%E7%A1%80/">JS基础</a></div><div class="post_share"><div class="social-share" data-image="https://images3.alphacoders.com/104/thumbbig-1043255.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/13/CSS%E7%AF%87/%E7%BB%98%E5%88%B60.5px%E8%BE%B9%E6%A1%86/"><img class="prev-cover" src="https://images.alphacoders.com/129/1296180.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">0.5px边框/线方法</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/10/JS%E7%AF%87/05.DOM/"><img class="next-cover" src="https://images2.alphacoders.com/949/thumbbig-949979.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DOM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/16/JS%E7%AF%87/01.%E5%9F%BA%E7%A1%80/" title="JS基础"><img class="cover" src="https://images5.alphacoders.com/949/thumbbig-949602.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-16</div><div class="title">JS基础</div></div></a></div><div><a href="/2023/01/09/JS%E7%AF%87/04.%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/" title="异步操作"><img class="cover" src="https://images.alphacoders.com/590/thumbbig-590486.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">异步操作</div></div></a></div><div><a href="/2023/01/08/JS%E7%AF%87/03.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象"><img class="cover" src="https://images5.alphacoders.com/492/thumbbig-492784.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-08</div><div class="title">面向对象</div></div></a></div><div><a href="/2023/01/06/JS%E7%AF%87/02.%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/" title="JS内置对象"><img class="cover" src="https://images5.alphacoders.com/659/thumbbig-659821.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-06</div><div class="title">JS内置对象</div></div></a></div><div><a href="/2023/01/10/JS%E7%AF%87/05.DOM/" title="DOM"><img class="cover" src="https://images2.alphacoders.com/949/thumbbig-949979.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-10</div><div class="title">DOM</div></div></a></div><div><a href="/2023/01/13/JS%E7%AF%87/07.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/" title="浏览器模型"><img class="cover" src="https://images3.alphacoders.com/919/thumbbig-919968.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-13</div><div class="title">浏览器模型</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjEwNS8zMjU2OA=="></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.liangzui.top/img/icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liang Zui</div><div class="author-info__description">爱生活，爱编程</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">379</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alison-yc"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">在学习的过程中完善博客内容，留存所学知识</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81EventTarget-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">一、EventTarget 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81EventTarget-addEventListener"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、EventTarget.addEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81EventTarget-removeEventListener"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、EventTarget.removeEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81EventTarget-dispatchEvent"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、EventTarget.dispatchEvent()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、监听函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-HTML-%E7%9A%84-on-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.2 HTML 的 on- 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B1%9E%E6%80%A7-%E4%BE%8B%EF%BC%9Ael-onclick"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 元素节点的事件属性 (例：el.onclick)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-EventTarget-addEventListener"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">1.3 EventTarget.addEventListener()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">1.4 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81this-%E7%9A%84%E6%8C%87%E5%90%91-%EF%BC%88%E6%8C%87%E5%90%91%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、this 的指向 （指向元素节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD%EF%BC%88%E6%8D%95%E8%8E%B7%E3%80%81%E7%9B%AE%E6%A0%87%E3%80%81%E5%86%92%E6%B3%A1%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、事件的传播（捕获、目标、冒泡）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、事件的代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-event-stopPropagation"><span class="toc-number">1.2.4.0.1.</span> <span class="toc-text">阻止事件冒泡 event.stopPropagation()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Event-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">三、Event 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Event-bubbles-%E6%98%AF%E5%90%A6%E4%BC%9A%E5%86%92%E6%B3%A1%EF%BC%8C%E5%8F%AA%E8%AF%BB%EF%BC%8CEvent-eventPhase-%E8%BF%94%E5%9B%9E%E6%95%B4%E6%95%B0%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BA%8B%E4%BB%B6%E6%89%80%E5%A4%84%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%8F%AA%E8%AF%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.1 Event.bubbles 是否会冒泡，只读，Event.eventPhase 返回整数，表示事件所处阶段，只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Event-cancelable-%E6%98%AF%E5%90%A6%E5%8F%AF%E5%8F%96%E6%B6%88%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%8CEvent-cancelBubble%E6%98%AF%E5%90%A6%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%EF%BC%8Cevent-defaultPrevented-%E6%98%AF%E5%90%A6%E8%B0%83%E7%94%A8%E8%BF%87%E5%8F%96%E6%B6%88%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.2 Event.cancelable 是否可取消默认行为，Event.cancelBubble是否阻止冒泡，event.defaultPrevented 是否调用过取消默认行为方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Event-currentTarget%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E9%80%9A%E8%BF%87%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8CEvent-target%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">2.3 Event.currentTarget当前正在通过的节点，Event.target目标节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Event-type-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%A6%82%EF%BC%9A%E2%80%99click%E2%80%99%EF%BC%89"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">2.4 Event.type 事件类型（如：’click’）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Event-timeStamp-%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E5%90%8E%E7%9A%84%E6%AF%AB%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">2.5 Event.timeStamp 相对于打开网页后的毫秒时间戳</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">1.3.2.5.0.1.</span> <span class="toc-text">例子：计算鼠标移动速度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-Event-isTrusted-%E6%98%AF%E5%90%A6%E7%94%B1%E7%9C%9F%E5%AE%9E%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">2.6 Event.isTrusted 是否由真实用户行为产生的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-Event-detail-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%86%E8%8A%82%EF%BC%88%E5%8D%95%E5%87%BBor%E5%8F%8C%E5%87%BB%E7%AD%89%EF%BC%89"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">2.7 Event.detail 事件的细节（单击or双击等）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Event-preventDefault-%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E5%BD%93%E5%89%8D%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 Event.preventDefault()  取消浏览器对当前事件的默认行为</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5%E5%AD%97%E6%AF%8D%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86"><span class="toc-number">1.3.3.1.0.1.</span> <span class="toc-text">例子：只能输入字母的输入框</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Event-stopPropagation-%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2 Event.stopPropagation() 阻止事件传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Event-stopImmediatePropagation-%E9%98%BB%E6%AD%A2%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3 Event.stopImmediatePropagation() 阻止同一个事件的其他监听函数被调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Event-composedPath-%E6%95%B0%E7%BB%84%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%92%8C%E5%86%92%E6%B3%A1%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.4 Event.composedPath() 数组，目标和冒泡的节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">四、鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、鼠标事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81MouseEvent-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、MouseEvent 接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81MouseEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、MouseEvent 接口的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-MouseEvent-altKey%EF%BC%8CMouseEvent-ctrlKey%EF%BC%8CMouseEvent-metaKey%EF%BC%8CMouseEvent-shiftKey"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.1 MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-MouseEvent-button-%E9%BC%A0%E6%A0%87%E7%9A%84%E5%93%AA%E4%B8%AA%E9%94%AE%EF%BC%8CMouseEvent-buttons%E5%90%8C%E6%97%B6%E6%8C%89%E5%93%AA%E4%BA%9B%E9%94%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.2 MouseEvent.button 鼠标的哪个键，MouseEvent.buttons同时按哪些键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-MouseEvent-clientX-%E7%9B%B8%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8X%E5%9D%90%E6%A0%87%EF%BC%8CMouseEvent-clientY-%E7%9B%B8%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8Y%E5%9D%90%E6%A0%87"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.3 MouseEvent.clientX 相对浏览器X坐标，MouseEvent.clientY 相对浏览器Y坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-MouseEvent-movementX-%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E4%BA%8B%E4%BB%B6%E7%9A%84X%E8%B7%9D%E7%A6%BB%EF%BC%8CMouseEvent-movementY-%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E4%BA%8B%E4%BB%B6%E7%9A%84Y%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">3.4 MouseEvent.movementX 上一个鼠标经过事件的X距离，MouseEvent.movementY 上一个鼠标经过事件的Y距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-MouseEvent-screenX-%E7%9B%B8%E5%AF%B9%E5%B1%8F%E5%B9%95X%E5%9D%90%E6%A0%87%EF%BC%8CMouseEvent-screenY-%E7%9B%B8%E5%AF%B9%E5%B1%8F%E5%B9%95Y%E5%9D%90%E6%A0%87"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">3.5 MouseEvent.screenX 相对屏幕X坐标，MouseEvent.screenY 相对屏幕Y坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-MouseEvent-offsetX-%E5%81%8F%E7%A7%BB%E9%87%8FX%EF%BC%8CMouseEvent-offsetY-%E5%81%8F%E7%A7%BB%E9%87%8FY"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">3.6 MouseEvent.offsetX 偏移量X，MouseEvent.offsetY 偏移量Y</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-MouseEvent-pageX-%E6%96%87%E6%A1%A3X%E5%9D%90%E6%A0%87%EF%BC%8CMouseEvent-pageY-%E6%96%87%E6%A1%A3Y%E5%9D%90%E6%A0%87"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">3.7 MouseEvent.pageX 文档X坐标，MouseEvent.pageY 文档Y坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-MouseEvent-relatedTarget-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">3.8 MouseEvent.relatedTarget 事件的相关节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81MouseEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、MouseEvent 接口的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-MouseEvent-getModifierState-%E6%98%AF%E5%90%A6%E6%8C%89%E4%B8%8B%E6%8C%87%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%94%AE"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">4.1 MouseEvent.getModifierState() 是否按下指定功能键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81WheelEvent-%E6%8E%A5%E5%8F%A3-%EF%BC%88%E6%BB%9A%E8%BD%AE%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、WheelEvent 接口 （滚轮）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">5.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">5.2 实例属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">五、键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、键盘事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81KeyboardEvent-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、KeyboardEvent 接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81KeyboardEvent-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.3.</span> <span class="toc-text">3、KeyboardEvent 的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-KeyboardEvent-altKey%EF%BC%8CKeyboardEvent-ctrlKey%EF%BC%8CKeyboardEvent-metaKey%EF%BC%8CKeyboardEvent-shiftKey-%E3%80%90%E6%98%AF%E5%90%A6%E6%8C%89%E4%B8%8B%E5%AF%B9%E5%BA%94%E9%94%AE%EF%BC%8C%E5%B8%83%E5%B0%94%E5%80%BC%E3%80%91"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">3.1 KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey 【是否按下对应键，布尔值】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-KeyboardEvent-code-%E9%94%AE%E7%A0%81"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">3.2 KeyboardEvent.code 键码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-KeyboardEvent-key-%E9%94%AE%E5%90%8D"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">3.3 KeyboardEvent.key 键名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-KeyboardEvent-location-%E9%94%AE%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E6%95%B4%E6%95%B0"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">3.4 KeyboardEvent.location 键处于哪个位置，整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-KeyboardEvent-repeat-%E6%98%AF%E5%90%A6%E9%95%BF%E6%8C%89"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">3.5 KeyboardEvent.repeat 是否长按</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81KeyboardEvent-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">4、KeyboardEvent 的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-KeyboardEvent-getModifierState-%E6%98%AF%E5%90%A6%E6%8C%89%E4%B8%8B%E6%8C%87%E5%AE%9A%E5%8A%9F%E8%83%BD%E9%94%AE"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">4.1 KeyboardEvent.getModifierState() 是否按下指定功能键</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">六、进度事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、进度事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81ProgressEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、ProgressEvent 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-ProgressEvent%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E3%80%82"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2.2 ProgressEvent的实例属性。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">七、表单事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">1、表单事件的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-input-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E5%80%BC%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E8%A7%A6%E5%8F%91%EF%BC%8C%E4%BC%9A%E8%BF%9E%E7%BB%AD%EF%BC%89"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1.1 input 事件 （值发生变化触发，会连续）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-select-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E9%80%89%E4%B8%AD%E6%96%87%E6%9C%AC%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">1.2 select 事件 （选中文本时触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-change-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E5%80%BC%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%8C%E5%8D%95%E6%AC%A1%EF%BC%89"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">1.3 change 事件 （值发生变化时触发，单次）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-invalid-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E4%B8%8D%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">1.4 invalid 事件 （表单提交不满足条件触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-reset-%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%87%8D%E7%BD%AE%EF%BC%89%EF%BC%8Csubmit-%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%8F%90%E4%BA%A4%EF%BC%89"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">1.5 reset 事件（重置），submit 事件（提交）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81InputEvent-%E6%8E%A5%E5%8F%A3%EF%BC%88input%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">2、InputEvent 接口（input事件的实例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89InputEvent-data-%E5%8F%98%E5%8A%A8%E7%9A%84%E9%82%A3%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">（1）InputEvent.data 变动的那部分内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89InputEvent-inputType-%E5%8F%98%E6%9B%B4%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">（2）InputEvent.inputType 变更类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89InputEvent-dataTransfer"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">（3）InputEvent.dataTransfer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">八、触摸事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A7%A6%E6%91%B8%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">1、触摸操作概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Touch-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.2.</span> <span class="toc-text">2、Touch 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Touch-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0-%EF%BC%88%E5%8D%95%E4%B8%AA%E8%A7%A6%E6%91%B8%E7%82%B9%EF%BC%89"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">2.1 Touch 接口概述 （单个触摸点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Touch-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2.2 Touch 接口的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Touch-identifier-%E8%A7%A6%E6%91%B8%E7%82%B9%E7%9A%84ID"><span class="toc-number">1.8.2.2.1.</span> <span class="toc-text">（1）Touch.identifier 触摸点的ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Touch-screenX%EF%BC%8CTouch-screenY%EF%BC%8CTouch-clientX%EF%BC%8CTouch-clientY%EF%BC%8CpageX%EF%BC%8CpageY-%EF%BC%88%E7%9B%B8%E5%AF%B9%E5%B1%8F%E5%B9%95%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81%E6%96%87%E6%A1%A3%E7%9A%84%E5%9D%90%E6%A0%87%EF%BC%89"><span class="toc-number">1.8.2.2.2.</span> <span class="toc-text">（2）Touch.screenX，Touch.screenY，Touch.clientX，Touch.clientY，pageX，pageY （相对屏幕、浏览器、文档的坐标）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Touch-radiusX%EF%BC%8CTouch-radiusY%EF%BC%8CTouch-rotationAngle-%EF%BC%88%E8%A7%A6%E6%91%B8%E6%A4%AD%E5%9C%86%E5%8C%BA%E5%9F%9F%E5%8D%8A%E5%BE%84%E3%80%81%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-number">1.8.2.2.3.</span> <span class="toc-text">（3）Touch.radiusX，Touch.radiusY，Touch.rotationAngle （触摸椭圆区域半径、角度）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89Touch-force-%E8%A7%A6%E6%91%B8%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.8.2.2.4.</span> <span class="toc-text">（4）Touch.force 触摸压力</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89Touch-target-%E5%BC%80%E5%A7%8B%E8%A7%A6%E6%91%B8%E6%97%B6%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.8.2.2.5.</span> <span class="toc-text">（5）Touch.target 开始触摸时的元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81TouchList-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">3、TouchList 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81TouchEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.4.</span> <span class="toc-text">4、TouchEvent 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">4.2 实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89TouchEvent-altKey%EF%BC%8CTouchEvent-ctrlKey%EF%BC%8CTouchEvent-shiftKey%EF%BC%8CTouchEvent-metaKey-%EF%BC%88%E6%98%AF%E5%90%A6%E5%90%8C%E6%97%B6%E6%8C%89%E6%9F%90%E4%BA%9B%E5%8A%9F%E8%83%BD%E9%94%AE%EF%BC%89"><span class="toc-number">1.8.4.2.1.</span> <span class="toc-text">（1）TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey （是否同时按某些功能键）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89TouchEvent-changedTouches-%EF%BC%88%E8%A7%A6%E6%91%B8%E7%82%B9%E9%9B%86%E5%90%88%EF%BC%8C%E4%B8%8D%E5%90%8C%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%90%AB%E4%B9%89%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="toc-number">1.8.4.2.2.</span> <span class="toc-text">（2）TouchEvent.changedTouches （触摸点集合，不同触摸事件，含义不同）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89TouchEvent-touches-%EF%BC%88%E4%BB%8D%E7%84%B6%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%A7%A6%E6%91%B8%E7%82%B9%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.8.4.2.3.</span> <span class="toc-text">（3）TouchEvent.touches （仍然活动的触摸点集合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89TouchEvent-targetTouches-%EF%BC%88%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E5%86%85%E6%B4%BB%E5%8A%A8%E7%9A%84%E8%A7%A6%E6%91%B8%E7%82%B9%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.8.4.2.4.</span> <span class="toc-text">（4）TouchEvent.targetTouches （目标元素内活动的触摸点集合）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.8.5.</span> <span class="toc-text">5、触摸事件的种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.9.</span> <span class="toc-text">九、拖拉事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.9.1.</span> <span class="toc-text">1、拖拉事件的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81DragEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.2.</span> <span class="toc-text">2、DragEvent 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DataTransfer-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">3、DataTransfer 接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81DataTransfer-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.4.</span> <span class="toc-text">4、DataTransfer 的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-DataTransfer-dropEffect-%E8%AE%BE%E7%BD%AE%E6%8E%A5%E5%8F%97%E6%8B%96%E6%8B%89%E7%9A%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">4.1 DataTransfer.dropEffect 设置接受拖拉的区域的效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-DataTransfer-effectAllowed-%E8%AE%BE%E7%BD%AE%E8%A2%AB%E6%8B%96%E6%8B%89%E7%9A%84%E8%8A%82%E7%82%B9%E5%85%81%E8%AE%B8%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">4.2 DataTransfer.effectAllowed 设置被拖拉的节点允许的效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-DataTransfer-files-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">4.3 DataTransfer.files 本地文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%8E%A5%E6%94%B6%E6%8B%96%E6%8B%89%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.4.3.1.</span> <span class="toc-text">例子：接收拖拉文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-DataTransfer-types-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">4.4 DataTransfer.types 数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-DataTransfer-items"><span class="toc-number">1.9.4.5.</span> <span class="toc-text">4.5 DataTransfer.items</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81DataTransfer-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.5.</span> <span class="toc-text">5、DataTransfer 的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-DataTransfer-setData-%E8%AE%BE%E7%BD%AE%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%E6%89%80%E5%B8%A6%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">5.1 DataTransfer.setData() 设置拖拉事件所带有的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-DataTransfer-getData-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">5.2 DataTransfer.getData() 返回指定类型的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-DataTransfer-clearData-%E6%B8%85%E9%99%A4%E6%8C%87%E5%AE%9A%E6%88%96%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">5.3 DataTransfer.clearData() 清除指定或全部数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-DataTransfer-setDragImage-%E8%AE%BE%E7%BD%AE%E6%8B%96%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87"><span class="toc-number">1.9.5.4.</span> <span class="toc-text">5.4 DataTransfer.setDragImage() 设置拖动过程中的图片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">十、其他常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%B5%84%E6%BA%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.1.</span> <span class="toc-text">1、资源事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-beforeunload-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3%E5%89%8D%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">1.1 beforeunload 事件 （关闭窗口前调用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-unload-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E5%8D%B3%E5%B0%86%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3%E6%97%B6%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">1.2 unload 事件 （即将关闭窗口时调用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-load-%E4%BA%8B%E4%BB%B6%EF%BC%8Cerror-%E4%BA%8B%E4%BB%B6-%EF%BC%8Cabort%E4%BA%8B%E4%BB%B6-%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%88%96%E6%9F%90%E4%B8%AA%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F-%E5%A4%B1%E8%B4%A5-%E5%8F%96%E6%B6%88%E6%97%B6%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">1.3 load 事件，error 事件 ，abort事件 （页面或某个资源加载成功&#x2F;失败&#x2F;取消时调用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81session-%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">2、session 历史事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-pageshow-%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%89%EF%BC%8Cpagehide-%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">2.1 pageshow 事件（页面显示，加载页面后执行），pagehide 事件（退出当前页面触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-popstate-%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84history%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%93%E5%89%8D%E8%AE%B0%E5%BD%95%E5%8F%91%E7%94%9F%E6%98%BE%E5%BC%8F%E5%88%87%E6%8D%A2%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">2.2 popstate 事件（在浏览器的history对象的当前记录发生显式切换时触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-hashchange-%E4%BA%8B%E4%BB%B6-%EF%BC%88hash%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">2.3 hashchange 事件 （hash发生变化时触发）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">3、网页状态事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-DOMContentLoaded-%E4%BA%8B%E4%BB%B6-%EF%BC%88DOM%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">3.1 DOMContentLoaded 事件 （DOM内容加载完成后触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-readystatechange-%E4%BA%8B%E4%BB%B6%EF%BC%88Document-%E5%AF%B9%E8%B1%A1%E5%92%8C-XMLHttpRequest-%E5%AF%B9%E8%B1%A1%E7%9A%84readyState%E5%B1%9E%E6%80%A7%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">3.2 readystatechange 事件（Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.4.</span> <span class="toc-text">4、窗口事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-scroll-%E4%BA%8B%E4%BB%B6-%EF%BC%88%E6%96%87%E6%A1%A3%E6%88%96%E6%96%87%E6%A1%A3%E5%85%83%E7%B4%A0%E6%BB%9A%E5%8A%A8%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">4.1 scroll 事件 （文档或文档元素滚动时触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-resize-%E4%BA%8B%E4%BB%B6%EF%BC%88%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">4.2 resize 事件（窗口大小变化时触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-fullscreenchange-%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%85%83%E7%B4%A0%E8%BF%9B%E5%85%A5-%E9%80%80%E5%87%BA%E5%85%A8%E5%B1%8F%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89%EF%BC%8Cfullscreenerror-%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2%E5%85%A8%E5%B1%8F%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">4.3 fullscreenchange 事件（元素进入&#x2F;退出全屏时触发），fullscreenerror 事件（无法切换全屏时触发）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.5.</span> <span class="toc-text">5、剪贴板事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.10.6.</span> <span class="toc-text">6、焦点事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81CustomEvent-%E6%8E%A5%E5%8F%A3%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.10.7.</span> <span class="toc-text">7、CustomEvent 接口（自定义事件）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81GlobalEventHandlers-%E6%8E%A5%E5%8F%A3-%EF%BC%88%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">十一、GlobalEventHandlers 接口 （全局事件处理接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81GlobalEventHandlers-onabort-%EF%BC%88%E4%B8%AD%E6%96%AD%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">1、GlobalEventHandlers.onabort （中断事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81GlobalEventHandlers-onerror-%EF%BC%88%E9%94%99%E8%AF%AF%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">2、GlobalEventHandlers.onerror （错误事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81GlobalEventHandlers-onload%EF%BC%88%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%89%E3%80%81GlobalEventHandlers-onloadstart%EF%BC%88%E5%BC%80%E5%A7%8B%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.11.3.</span> <span class="toc-text">3、GlobalEventHandlers.onload（加载完成事件）、GlobalEventHandlers.onloadstart（开始加载事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81GlobalEventHandlers-onfocus%EF%BC%88%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%EF%BC%89%EF%BC%8CGlobalEventHandlers-onblur%EF%BC%88%E5%A4%B1%E5%8E%BB%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">4、GlobalEventHandlers.onfocus（获取焦点事件），GlobalEventHandlers.onblur（失去焦点事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81GlobalEventHandlers-onscroll%EF%BC%88%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">1.11.5.</span> <span class="toc-text">5、GlobalEventHandlers.onscroll（滚动事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81GlobalEventHandlers-oncontextmenu%EF%BC%88%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E4%BA%8B%E4%BB%B6%EF%BC%89%EF%BC%8CGlobalEventHandlers-onshow%EF%BC%88%E6%98%BE%E7%A4%BA%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%97%B6%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-number">1.11.6.</span> <span class="toc-text">6、GlobalEventHandlers.oncontextmenu（右键菜单事件），GlobalEventHandlers.onshow（显示右键菜单时触发）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%85%B6%E4%BB%96%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">1.11.7.</span> <span class="toc-text">7、其他的事件属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">1.12.</span> <span class="toc-text">文档</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%9B%9E%E6%96%87%E6%95%B0/" title="回文数"><img src="https://images4.alphacoders.com/133/thumbbig-1339110.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="回文数"/></a><div class="content"><a class="title" href="/2023/12/12/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%9B%9E%E6%96%87%E6%95%B0/" title="回文数">回文数</a><time datetime="2023-12-11T16:01:01.000Z" title="发表于 2023-12-12 00:01:01">2023-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/11/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/" title="移除元素"><img src="https://images5.alphacoders.com/134/thumbbig-1343552.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="移除元素"/></a><div class="content"><a class="title" href="/2023/12/11/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/" title="移除元素">移除元素</a><time datetime="2023-12-10T16:05:01.000Z" title="发表于 2023-12-11 00:05:01">2023-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/" title="字符串中的单词数"><img src="https://images6.alphacoders.com/131/thumbbig-1317396.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字符串中的单词数"/></a><div class="content"><a class="title" href="/2023/12/10/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/" title="字符串中的单词数">字符串中的单词数</a><time datetime="2023-12-10T15:11:01.000Z" title="发表于 2023-12-10 23:11:01">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/08/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" title="用队列实现栈"><img src="https://images5.alphacoders.com/872/thumbbig-872306.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用队列实现栈"/></a><div class="content"><a class="title" href="/2023/12/08/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" title="用队列实现栈">用队列实现栈</a><time datetime="2023-12-07T16:32:01.000Z" title="发表于 2023-12-08 00:32:01">2023-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/" title="完全二叉树的节点个数"><img src="https://images3.alphacoders.com/667/thumbbig-667031.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="完全二叉树的节点个数"/></a><div class="content"><a class="title" href="/2023/12/07/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%83/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/" title="完全二叉树的节点个数">完全二叉树的节点个数</a><time datetime="2023-12-06T16:11:01.000Z" title="发表于 2023-12-07 00:11:01">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Liang Zui</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3RWXwk0rF8EQ1GTu7v1LQxpn-gzGzoHsz',
      appKey: 'foGJSAlMIauf7cSGcEODcWAV',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Livere' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>